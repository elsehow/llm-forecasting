"""Shared LLM signal generation for scenario construction.

Used by top-down and dual approaches to generate signals from uncertainties.
"""

from uuid import uuid4

from pydantic import BaseModel, Field
import litellm

from .signals import RESOLVABILITY_REQUIREMENTS

# Model for signal generation
DEFAULT_MODEL = "claude-sonnet-4-20250514"


class GeneratedSignal(BaseModel):
    """A signal generated by LLM with full metadata."""

    text: str = Field(description="The signal as a resolvable prediction market question")
    background: str = Field(description="Why this signal is cruxy for this uncertainty")
    resolution_date: str = Field(
        description="ISO date when this signal should resolve, e.g., '2028-12-31'"
    )
    resolution_source: str | None = Field(
        default=None,
        description="Where to check resolution (e.g., 'BLS productivity data', 'SEC filings')",
    )
    base_rate: float | None = Field(
        default=None,
        description="Estimated probability P(signal=yes), or null if highly uncertain",
    )


class SignalsResponse(BaseModel):
    """Response with generated signals."""

    signals: list[GeneratedSignal]


SIGNAL_GENERATION_PROMPT = """You are generating cruxy signals for a specific uncertainty axis.

TARGET QUESTION: {question}
UNCERTAINTY AXIS: {uncertainty_name}
DESCRIPTION: {uncertainty_description}

Generate {n} signals that would most inform this uncertainty.

{resolvability}

For EACH signal, provide:
1. **text**: The signal as a resolvable prediction market question
2. **background**: Why this signal is cruxy for this uncertainty (1-2 sentences)
3. **resolution_date**: ISO date when this should resolve (e.g., "2028-12-31")
4. **resolution_source**: Where to check if this resolved (e.g., "BLS productivity data", "UN population report", "SEC 10-K filings")
5. **base_rate**: Your estimate of P(signal=yes), or null if highly uncertain

Focus on signals that:
1. Directly relate to this uncertainty axis
2. Resolve in 2-5 years (trackable timeframe)
3. Would significantly update probability if observed
4. Cover different aspects of this uncertainty
"""


async def generate_signals_for_uncertainty(
    question: str,
    uncertainty_name: str,
    uncertainty_description: str,
    n: int = 10,
    model: str = DEFAULT_MODEL,
) -> list[dict]:
    """
    Generate LLM signals for a specific uncertainty axis.

    Args:
        question: The target forecasting question
        uncertainty_name: Name of the uncertainty axis
        uncertainty_description: Description of the uncertainty
        n: Number of signals to generate
        model: LLM model to use

    Returns:
        List of signal dicts with keys:
        - id: Generated unique ID (llm_XXXXXXXX)
        - text: Signal text
        - background: Why this signal matters
        - resolution_date: ISO date string
        - resolution_source: Where to check resolution
        - base_rate: Estimated probability
        - source: "llm"
        - uncertainty_source: Which uncertainty axis
    """
    response = await litellm.acompletion(
        model=model,
        messages=[
            {
                "role": "user",
                "content": SIGNAL_GENERATION_PROMPT.format(
                    question=question,
                    uncertainty_name=uncertainty_name,
                    uncertainty_description=uncertainty_description,
                    n=n,
                    resolvability=RESOLVABILITY_REQUIREMENTS,
                ),
            }
        ],
        response_format=SignalsResponse,
    )

    result = SignalsResponse.model_validate_json(response.choices[0].message.content)

    return [
        {
            "id": f"llm_{uuid4().hex[:8]}",
            "text": s.text,
            "background": s.background,
            "resolution_date": s.resolution_date,
            "resolution_source": s.resolution_source,
            "base_rate": s.base_rate,
            "source": "llm",
            "uncertainty_source": uncertainty_name,
        }
        for s in result.signals
    ]
