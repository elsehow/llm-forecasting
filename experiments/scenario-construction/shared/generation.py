"""Shared LLM signal generation for scenario construction.

Used by top-down and dual approaches to generate signals from uncertainties.
"""

from datetime import datetime, timedelta, timezone
from uuid import uuid4

from pydantic import BaseModel, Field
import litellm

from .signals import RESOLVABILITY_REQUIREMENTS, DEFAULT_MAX_HORIZON_DAYS, compute_signal_cutoff

# Model for signal generation
DEFAULT_MODEL = "claude-sonnet-4-20250514"


class GeneratedSignal(BaseModel):
    """A signal generated by LLM with full metadata."""

    text: str = Field(description="The signal as a resolvable prediction market question")
    background: str = Field(description="Why this signal is cruxy for this uncertainty")
    resolution_date: str = Field(
        description="ISO date when this signal should resolve, e.g., '2028-12-31'"
    )
    resolution_source: str | None = Field(
        default=None,
        description="Where to check resolution (e.g., 'BLS productivity data', 'SEC filings')",
    )
    base_rate: float | None = Field(
        default=None,
        description="Estimated probability P(signal=yes), or null if highly uncertain",
    )


class SignalsResponse(BaseModel):
    """Response with generated signals."""

    signals: list[GeneratedSignal]


SIGNAL_GENERATION_PROMPT = """You are generating cruxy signals for a specific uncertainty axis.

TARGET QUESTION: {question}
UNCERTAINTY AXIS: {uncertainty_name}
DESCRIPTION: {uncertainty_description}

TODAY'S DATE: {today}
RESOLUTION WINDOW: Signals must resolve between {min_date} and {max_date}

Generate {n} signals that would most inform this uncertainty.

{resolvability}

For EACH signal, provide:
1. **text**: The signal as a resolvable prediction market question
2. **background**: Why this signal is cruxy for this uncertainty (1-2 sentences)
3. **resolution_date**: ISO date when this should resolve (MUST be between {min_date} and {max_date})
4. **resolution_source**: Where to check if this resolved (e.g., "BLS productivity data", "UN population report", "SEC 10-K filings")
5. **base_rate**: Your estimate of P(signal=yes), or null if highly uncertain

Focus on signals that:
1. Directly relate to this uncertainty axis
2. Resolve within the specified window ({min_date} to {max_date})
3. Would significantly update probability if observed
4. Cover different aspects of this uncertainty
"""


async def generate_signals_for_uncertainty(
    question: str,
    uncertainty_name: str,
    uncertainty_description: str,
    n: int = 10,
    max_horizon_days: int = DEFAULT_MAX_HORIZON_DAYS,
    target_resolution_date=None,
    model: str = DEFAULT_MODEL,
) -> list[dict]:
    """
    Generate LLM signals for a specific uncertainty axis.

    Args:
        question: The target forecasting question
        uncertainty_name: Name of the uncertainty axis
        uncertainty_description: Description of the uncertainty
        n: Number of signals to generate
        max_horizon_days: Maximum days until signal resolution (default 365)
        target_resolution_date: Target question resolution date (date or ISO string).
            If provided, cutoff is min(max_horizon_days, 1/3 time to target resolution).
        model: LLM model to use

    Returns:
        List of signal dicts with keys:
        - id: Generated unique ID (llm_XXXXXXXX)
        - text: Signal text
        - background: Why this signal matters
        - resolution_date: ISO date string
        - resolution_source: Where to check resolution
        - base_rate: Estimated probability
        - source: "llm"
        - uncertainty_source: Which uncertainty axis
    """
    # Compute effective horizon using smart cutoff
    effective_horizon = compute_signal_cutoff(target_resolution_date, max_horizon_days)

    # Compute date window
    today = datetime.now().date()
    min_date = today + timedelta(days=1)  # Tomorrow (not already resolved)
    max_date = today + timedelta(days=effective_horizon)

    response = await litellm.acompletion(
        model=model,
        messages=[
            {
                "role": "user",
                "content": SIGNAL_GENERATION_PROMPT.format(
                    question=question,
                    uncertainty_name=uncertainty_name,
                    uncertainty_description=uncertainty_description,
                    n=n,
                    today=today.isoformat(),
                    min_date=min_date.isoformat(),
                    max_date=max_date.isoformat(),
                    resolvability=RESOLVABILITY_REQUIREMENTS,
                ),
            }
        ],
        response_format=SignalsResponse,
    )

    result = SignalsResponse.model_validate_json(response.choices[0].message.content)

    now = datetime.now(timezone.utc)
    return [
        {
            "id": f"llm_{uuid4().hex[:8]}",
            "text": s.text,
            "background": s.background,
            "resolution_date": s.resolution_date,
            "resolution_source": s.resolution_source,
            "base_rate": s.base_rate,
            "source": "llm",
            "uncertainty_source": uncertainty_name,
            "probability_source": "llm_estimate" if s.base_rate is not None else None,
            "probability_at": now.isoformat() if s.base_rate is not None else None,
        }
        for s in result.signals
    ]
