<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scenario Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #fafafa;
      --bg-secondary: #f5f5f5;
      --text-primary: #1a1a1a;
      --text-secondary: #525252;
      --text-muted: #a3a3a3;
      --border: #e5e5e5;
      --border-strong: #d4d4d4;

      --signal-bg: #f0fdf4;
      --signal-border: #86efac;
      --signal-text: #166534;
      --signal-highlight: #dcfce7;

      --scenario-bg: #fffbeb;
      --scenario-border: #fcd34d;
      --scenario-text: #92400e;
      --scenario-highlight: #fef3c7;

      --question-bg: #eff6ff;
      --question-border: #93c5fd;
      --question-text: #1e40af;
      --question-highlight: #dbeafe;

      --up-color: #16a34a;
      --down-color: #dc2626;

      --radius-sm: 6px;
      --radius-md: 10px;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);

      /* Source colors */
      --polymarket: #7c3aed;
      --metaculus: #2563eb;
      --manifold: #059669;
      --infer: #d97706;
      --fred: #dc2626;
      --llm: #6b7280;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      background: linear-gradient(to bottom, var(--bg-primary), var(--bg-secondary));
      border-bottom: 1px solid var(--border);
    }

    .header-left { display: flex; align-items: center; gap: 1rem; }

    h1 {
      font-weight: 600;
      font-size: 1.25rem;
      letter-spacing: -0.025em;
      color: var(--text-primary);
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.75rem;
      font-weight: 400;
    }

    .stats-bar {
      display: flex;
      gap: 1.5rem;
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .stat { display: flex; align-items: center; gap: 0.25rem; }
    .stat-value { font-weight: 600; color: var(--text-secondary); font-variant-numeric: tabular-nums; }

    .explorer-container { position: relative; height: calc(100vh - 60px); overflow: hidden; }
    .explorer { display: grid; grid-template-columns: 320px 1fr 320px; gap: 0; height: 100%; position: relative; }

    #connections-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .flow-path {
      fill: none;
      stroke: rgba(200, 200, 200, 0.3);
      stroke-width: 2;
      transition: stroke 0.2s, stroke-width 0.2s, opacity 0.2s;
    }
    .flow-path.up { stroke: rgba(22, 163, 74, 0.4); }
    .flow-path.down { stroke: rgba(220, 38, 38, 0.4); }
    .flow-path.highlighted {
      opacity: 1;
      stroke: #1a1a1a;
    }
    .flow-path.highlighted.up { stroke: var(--up-color); }
    .flow-path.highlighted.down { stroke: var(--down-color); }
    .flow-path.dimmed { opacity: 0.1; }

    .column {
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 0.75rem;
      background: var(--bg-primary);
      min-height: 0;
    }

    .column::-webkit-scrollbar { width: 6px; }
    .column::-webkit-scrollbar-track { background: transparent; }
    .column::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 3px; }

    .column-header {
      text-align: center;
      font-size: 0.65rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      padding: 0.5rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 0.5rem;
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      z-index: 10;
    }

    .scenarios-column {
      background: var(--bg-secondary);
    }
    .scenarios-column .column-header { background: var(--bg-secondary); }

    .cards-container { display: flex; flex-direction: column; gap: 0.4rem; }

    .card {
      padding: 0.6rem 0.75rem;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1.5px solid transparent;
      position: relative;
      box-shadow: var(--shadow-sm);
    }
    .card:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    .card.dimmed { opacity: 0.15; pointer-events: none; }
    .card.highlighted {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    /* Signal Cards */
    .signal-card {
      background: var(--signal-bg);
      border-color: var(--signal-border);
      color: var(--signal-text);
      font-size: 0.72rem;
      line-height: 1.4;
    }
    .signal-card.highlighted {
      border-color: var(--signal-text);
      background: var(--signal-highlight);
    }
    .signal-card.synthetic {
      border-style: dashed;
    }
    .signal-card.zero-voi {
      opacity: 0.4;
      background: var(--bg-secondary);
      border-color: var(--border);
      color: var(--text-muted);
    }
    .signal-card.zero-voi .source-badge {
      background: var(--text-muted);
    }
    .signal-card.zero-voi .signal-voi {
      color: var(--text-muted);
    }

    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
    }

    .signal-name {
      font-weight: 500;
      flex: 1;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .signal-card.highlighted .signal-name {
      -webkit-line-clamp: unset;
    }

    .source-badge {
      font-size: 0.55rem;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      white-space: nowrap;
    }
    .source-badge.polymarket { background: var(--polymarket); color: white; }
    .source-badge.metaculus { background: var(--metaculus); color: white; }
    .source-badge.manifold { background: var(--manifold); color: white; }
    .source-badge.infer { background: var(--infer); color: white; }
    .source-badge.fred { background: var(--fred); color: white; }
    .source-badge.llm { background: var(--llm); color: white; }

    .signal-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.6rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
    }

    .signal-voi {
      font-weight: 600;
      color: var(--signal-text);
    }

    .signal-prob {
      font-weight: 500;
    }
    .signal-prob.synthetic::after {
      content: ' est.';
      font-weight: 400;
      font-style: italic;
    }

    .signal-rho {
      display: none;
      margin-top: 0.35rem;
      font-size: 0.6rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }
    .signal-card.highlighted .signal-rho {
      display: block;
    }

    /* Scenario Cards */
    .scenario-card {
      background: var(--scenario-bg);
      border-color: var(--scenario-border);
      color: var(--scenario-text);
      font-size: 0.75rem;
    }
    .scenario-card.highlighted {
      border-color: var(--scenario-text);
      background: var(--scenario-highlight);
    }

    .scenario-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .scenario-name {
      font-weight: 600;
      font-size: 0.85rem;
    }

    .scenario-range {
      font-weight: 600;
      font-size: 0.8rem;
      color: var(--scenario-text);
    }

    .scenario-prob-bar {
      height: 4px;
      background: rgba(0,0,0,0.1);
      border-radius: 2px;
      margin: 0.4rem 0;
      overflow: hidden;
    }
    .scenario-prob-fill {
      height: 100%;
      background: var(--scenario-text);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    .scenario-description {
      display: none;
      font-size: 0.7rem;
      line-height: 1.5;
      color: var(--text-secondary);
      margin-top: 0.5rem;
    }
    .scenario-card.highlighted .scenario-description {
      display: block;
    }

    .scenario-drivers {
      display: none;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--scenario-border);
    }
    .scenario-card.highlighted .scenario-drivers {
      display: block;
    }

    .driver-label {
      font-size: 0.6rem;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .driver-list {
      font-size: 0.65rem;
      color: var(--text-secondary);
      padding-left: 1rem;
    }
    .driver-list li {
      margin-bottom: 0.15rem;
    }

    /* Question Card */
    .question-card {
      background: var(--question-bg);
      border-color: var(--question-border);
      color: var(--question-text);
      font-size: 0.8rem;
    }
    .question-card.highlighted {
      border-color: var(--question-text);
      background: var(--question-highlight);
    }

    .question-text {
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 0.75rem;
    }

    .question-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
    }
    .question-value.positive { color: var(--up-color); }
    .question-value.negative { color: var(--down-color); }

    .question-label {
      font-size: 0.65rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .question-range {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .range-bar {
      flex: 1;
      height: 8px;
      background: rgba(0,0,0,0.1);
      border-radius: 4px;
      position: relative;
    }

    .range-marker {
      position: absolute;
      top: -2px;
      width: 12px;
      height: 12px;
      background: var(--question-text);
      border-radius: 50%;
      transform: translateX(-50%);
      transition: left 0.3s ease;
    }
    .range-marker.baseline {
      background: var(--text-muted);
      width: 8px;
      height: 8px;
      top: 0;
      z-index: 1;
    }
    .range-marker.scenario {
      z-index: 2;
    }
    .range-marker.scenario.up { background: var(--up-color); }
    .range-marker.scenario.down { background: var(--down-color); }

    .scenario-range-highlight {
      position: absolute;
      top: 0;
      height: 100%;
      border-radius: 4px;
      opacity: 0.3;
    }
    .scenario-range-highlight.up { background: var(--up-color); }
    .scenario-range-highlight.down { background: var(--down-color); }

    .range-endpoints {
      display: flex;
      justify-content: space-between;
      font-size: 0.6rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }

    .scenario-outcome {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--question-border);
    }
    .scenario-outcome.visible {
      display: block;
    }

    .outcome-label {
      font-size: 0.65rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .outcome-value {
      font-size: 1.2rem;
      font-weight: 600;
    }
    .outcome-value.positive { color: var(--up-color); }
    .outcome-value.negative { color: var(--down-color); }

    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .error {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--down-color);
      font-size: 0.9rem;
      text-align: center;
      padding: 2rem;
    }

    /* Dropdown */
    .file-selector {
      padding: 0.4rem 0.75rem;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
      min-width: 200px;
    }
    .file-selector:focus {
      outline: none;
      border-color: var(--question-border);
    }

    /* Approach toggle */
    .approach-toggle {
      display: flex;
      gap: 0;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }
    .approach-btn {
      padding: 0.4rem 0.75rem;
      font-size: 0.7rem;
      font-weight: 500;
      background: var(--bg-primary);
      border: none;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.15s;
      border-right: 1px solid var(--border);
    }
    .approach-btn:last-child {
      border-right: none;
    }
    .approach-btn:hover {
      background: var(--bg-secondary);
    }
    .approach-btn.active {
      background: var(--question-bg);
      color: var(--question-text);
      font-weight: 600;
    }
    .approach-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .selector-group {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .selector-label {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Probability shift display */
    .prob-shift {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.65rem;
      margin-top: 0.25rem;
    }
    .prob-original {
      color: var(--text-muted);
      text-decoration: line-through;
    }
    .prob-arrow {
      color: var(--text-muted);
    }
    .prob-current {
      font-weight: 600;
    }
    .prob-current.up {
      color: var(--up-color);
    }
    .prob-current.down {
      color: var(--down-color);
    }
    .prob-delta {
      font-size: 0.6rem;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }
    .prob-delta.up {
      background: rgba(22, 163, 74, 0.1);
      color: var(--up-color);
    }
    .prob-delta.down {
      background: rgba(220, 38, 38, 0.1);
      color: var(--down-color);
    }

    /* Cruxiness Bar */
    .cruxiness-bar {
      display: none;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--signal-border);
    }
    .signal-card.highlighted .cruxiness-bar,
    .signal-card:hover .cruxiness-bar {
      display: block;
    }
    .cruxiness-track {
      height: 14px;
      background: var(--bg-secondary);
      border-radius: 3px;
      position: relative;
      border: 1px solid var(--border);
      margin: 0 0.25rem;
    }
    .cruxiness-spread-fill {
      position: absolute;
      top: 2px;
      bottom: 2px;
      background: linear-gradient(to right, var(--down-color), var(--up-color));
      opacity: 0.2;
      border-radius: 2px;
    }
    .cruxiness-marker {
      position: absolute;
      top: 1px;
      bottom: 1px;
      width: 3px;
      border-radius: 1px;
      transform: translateX(-50%);
    }
    .cruxiness-marker.yes { background: var(--up-color); }
    .cruxiness-marker.no { background: var(--down-color); }
    .cruxiness-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.2rem;
      font-size: 0.55rem;
    }
    .cruxiness-label-item {
      display: flex;
      align-items: center;
      gap: 0.2rem;
    }
    .cruxiness-label-item.no { color: var(--down-color); }
    .cruxiness-label-item.yes { color: var(--up-color); }
    .cruxiness-label-value { font-weight: 600; }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-left">
      <h1>Scenario Explorer</h1>
      <div class="selector-group">
        <span class="selector-label">Question</span>
        <select id="target-selector" class="file-selector">
          <option value="">Select question...</option>
        </select>
      </div>
      <div class="selector-group">
        <span class="selector-label">Approach</span>
        <div class="approach-toggle" id="approach-toggle">
          <button class="approach-btn" data-approach="bottomup" disabled>Bottom-up</button>
          <button class="approach-btn" data-approach="topdown" disabled>Top-down</button>
          <button class="approach-btn" data-approach="hybrid" disabled>Hybrid</button>
          <button class="approach-btn" data-approach="dual" disabled>Dual</button>
        </div>
      </div>
    </div>
    <div class="stats-bar">
      <div class="stat">Signals: <span class="stat-value" id="stat-signals">-</span></div>
      <div class="stat">Scenarios: <span class="stat-value" id="stat-scenarios">-</span></div>
    </div>
  </div>

  <div class="explorer-container">
    <svg id="connections-svg"></svg>
    <div class="explorer" id="explorer">
      <div class="column" id="signals-col">
        <div class="column-header">
          SIGNALS
          <select id="signal-sort" style="margin-left: 0.5rem; font-size: 0.6rem; padding: 0.15rem 0.3rem;">
            <option value="resolution_date">By resolution date</option>
            <option value="voi">By VOI</option>
            <option value="cruxiness">By cruxiness</option>
          </select>
        </div>
        <div class="cards-container" id="signals-container"></div>
      </div>
      <div class="column scenarios-column" id="scenarios-col">
        <div class="column-header">SCENARIOS</div>
        <div class="cards-container" id="scenarios-container"></div>
      </div>
      <div class="column" id="question-col">
        <div class="column-header">QUESTION</div>
        <div id="question-container"></div>
      </div>
    </div>
  </div>

  <script>
    // =============================================================
    // State (single source of truth)
    // =============================================================
    const state = {
      data: null,
      files: [],  // All available files from API
      selectedTarget: null,
      selectedApproach: null,
      selection: {
        signalId: null,
        scenarioName: null,
      },
      signalSort: 'resolution_date', // 'resolution_date' or 'voi'
      resolutions: {},  // signalId -> 'yes' | 'no' | null (pending)
    };

    // Observed sources (vs synthetic)
    // Keep in sync with llm_forecasting.semantic_search.OBSERVED_SOURCES
    const OBSERVED_SOURCES = ['polymarket', 'metaculus', 'kalshi', 'manifold', 'infer', 'fred', 'yfinance'];

    // =============================================================
    // Pure render functions
    // =============================================================

    function render(state) {
      if (!state.data) return;
      renderHeader(state);
      renderSignals(state);
      renderScenarios(state);
      renderQuestion(state);
      requestAnimationFrame(() => renderPaths(state));
    }

    function renderHeader(state) {
      // Count only signals that are mapped to at least one scenario
      const signals = state.data.signals || [];
      const scenarios = state.data.scenarios || [];
      const mappedIndices = new Set();
      scenarios.forEach(scenario => {
        getScenarioSignalIndices(scenario, signals).forEach(idx => mappedIndices.add(idx));
      });
      document.getElementById('stat-signals').textContent = mappedIndices.size;
      document.getElementById('stat-scenarios').textContent = scenarios.length;

      // Count resolved signals
    }

    // Helper: get signal indices mapped to a scenario (supports both old and new format)
    function getScenarioSignalIndices(scenario, signals) {
      // New format: signal_impacts with indices
      if (scenario.signal_impacts?.length > 0) {
        return scenario.signal_impacts.map(si => si.signal_index);
      }
      // Old format: mapped_signals with text (fallback)
      if (scenario.mapped_signals?.length > 0) {
        const indices = [];
        scenario.mapped_signals.forEach(text => {
          const textLower = text.toLowerCase().slice(0, 50);
          signals.forEach((s, idx) => {
            if (s.text.toLowerCase().startsWith(textLower)) {
              indices.push(idx);
            }
          });
        });
        return indices;
      }
      return [];
    }

    // Helper: get signal impact for a signal in a scenario
    function getSignalImpact(scenario, signalIndex) {
      if (scenario.signal_impacts?.length > 0) {
        return scenario.signal_impacts.find(si => si.signal_index === signalIndex);
      }
      return null;
    }

    // Helper: render probability shift display (original → current with delta)
    function renderProbabilityShift(original, current, formatFn = (v) => `${(v * 100).toFixed(0)}%`, options = {}) {
      const { centered = false, deltaUnit = 'pp' } = options;
      const delta = current - original;
      const deltaClass = delta > 0 ? 'up' : 'down';
      const deltaSign = delta > 0 ? '+' : '';
      const style = centered ? ' style="justify-content: center;"' : '';

      return `
        <div class="prob-shift"${style}>
          <span class="prob-original">${formatFn(original)}</span>
          <span class="prob-arrow">→</span>
          <span class="prob-current ${deltaClass}">${formatFn(current)}</span>
          <span class="prob-delta ${deltaClass}">${deltaSign}${deltaUnit === 'pp' ? (delta * 100).toFixed(0) + 'pp' : formatFn(Math.abs(delta))}</span>
        </div>
      `;
    }

    // Helper: render range bar content with optional markers and highlights
    function renderRangeBar(baselinePos, options = {}) {
      const {
        baselineTitle = '',
        scenarioPos = null,
        scenarioLowPos = null,
        scenarioHighPos = null,
        colorClass = '',
        // For signal cruxiness display
        yesPos = null,
        noPos = null,
        yesTitle = '',
        noTitle = '',
        gradientDir = 'to right',
      } = options;

      // Just baseline marker (default)
      if (scenarioPos === null && yesPos === null) {
        return `<div class="range-marker" style="left: ${baselinePos}%"></div>`;
      }

      // Signal cruxiness display (two markers: YES and NO)
      if (yesPos !== null && noPos !== null) {
        const spreadLeft = Math.min(yesPos, noPos);
        const spread = Math.abs(yesPos - noPos);
        return `
          <div class="scenario-range-highlight" style="left: ${spreadLeft}%; width: ${spread}%; background: linear-gradient(${gradientDir}, var(--down-color), var(--up-color)); opacity: 0.25;"></div>
          <div class="range-marker baseline" style="left: ${baselinePos}%" title="${baselineTitle}"></div>
          <div class="range-marker scenario down" style="left: ${noPos}%" title="${noTitle}"></div>
          <div class="range-marker scenario up" style="left: ${yesPos}%" title="${yesTitle}"></div>
        `;
      }

      // Scenario comparison display (highlight range + scenario marker)
      if (scenarioLowPos !== null && scenarioHighPos !== null) {
        return `
          <div class="scenario-range-highlight ${colorClass}" style="left: ${scenarioLowPos}%; width: ${scenarioHighPos - scenarioLowPos}%"></div>
          <div class="range-marker baseline" style="left: ${baselinePos}%" title="${baselineTitle}"></div>
          <div class="range-marker scenario ${colorClass}" style="left: ${scenarioPos}%"></div>
        `;
      }

      // Fallback: just baseline
      return `<div class="range-marker" style="left: ${baselinePos}%"></div>`;
    }

    // Helper: get scenario midpoint value (works for both quantitative and binary)
    function getScenarioMidpoint(scenario) {
      // Quantitative questions use outcome_low/high
      if (scenario.outcome_low != null && scenario.outcome_high != null) {
        return (scenario.outcome_low + scenario.outcome_high) / 2;
      }
      // Binary questions use probability_low/high
      if (scenario.probability_low != null && scenario.probability_high != null) {
        return (scenario.probability_low + scenario.probability_high) / 2;
      }
      return null;
    }

    // Helper: compute expected value across scenarios (works for both question types)
    function computeExpectedValue(scenarios, probabilities) {
      let total = 0;
      scenarios.forEach((scenario, i) => {
        const midpoint = getScenarioMidpoint(scenario);
        if (midpoint != null) {
          total += midpoint * probabilities[i];
        }
      });
      return total;
    }

    // Helper: get scenario bar positions for comparison display
    function getScenarioBarPositions(scenario, baseline, valueRange) {
      const [minVal, maxVal] = valueRange;
      const range = maxVal - minVal;
      const midpoint = getScenarioMidpoint(scenario);
      if (midpoint == null) return null;

      // Get low/high bounds based on question type
      const isQuantitative = scenario.outcome_low != null;
      const low = isQuantitative ? scenario.outcome_low : scenario.probability_low;
      const high = isQuantitative ? scenario.outcome_high : scenario.probability_high;

      // Convert to percentage positions
      const lowPos = ((low - minVal) / range) * 100;
      const highPos = ((high - minVal) / range) * 100;
      const midPos = ((midpoint - minVal) / range) * 100;
      const isUp = midpoint >= baseline;

      return {
        lowPos,
        highPos,
        midPos,
        midpoint,
        isUp,
        colorClass: isUp ? 'up' : 'down',
        valueColorClass: isUp ? 'positive' : 'negative',
      };
    }

    function renderSignals(state) {
      const container = document.getElementById('signals-container');
      container.innerHTML = '';

      const signals = state.data.signals || [];
      const scenarios = state.data.scenarios || [];
      const { signalId, scenarioName } = state.selection;

      // Find which signal indices are mapped to selected scenario
      let mappedSignalIndices = new Set();
      if (scenarioName) {
        const scenario = scenarios.find(s => s.name === scenarioName);
        if (scenario) {
          getScenarioSignalIndices(scenario, signals).forEach(idx => mappedSignalIndices.add(idx));
        }
      }

      // Build set of all signal indices mapped to any scenario
      const allMappedIndices = new Set();
      scenarios.forEach(scenario => {
        getScenarioSignalIndices(scenario, signals).forEach(idx => allMappedIndices.add(idx));
      });

      // Filter to only signals that are mapped to at least one scenario
      const signalsWithIndex = signals
        .map((signal, idx) => ({ signal, originalIndex: idx }))
        .filter(({ originalIndex }) => allMappedIndices.has(originalIndex));

      // Sort based on user selection
      if (state.signalSort === 'voi') {
        signalsWithIndex.sort((a, b) => (b.signal.voi || 0) - (a.signal.voi || 0));
      } else if (state.signalSort === 'cruxiness') {
        signalsWithIndex.sort((a, b) => (b.signal.cruxiness_spread || 0) - (a.signal.cruxiness_spread || 0));
      } else {
        // Sort by resolution date (soonest first, nulls last)
        signalsWithIndex.sort((a, b) => {
          const dateA = a.signal.resolution_date ? new Date(a.signal.resolution_date) : new Date('9999-12-31');
          const dateB = b.signal.resolution_date ? new Date(b.signal.resolution_date) : new Date('9999-12-31');
          return dateA - dateB;
        });
      }

      signalsWithIndex.forEach(({ signal, originalIndex: signalIndex }) => {
        const isObserved = OBSERVED_SOURCES.includes(signal.source);
        const isSelected = signalId === signal.id;
        const isMapped = scenarioName && mappedSignalIndices.has(signalIndex);

        let classes = ['card', 'signal-card'];
        if (!isObserved) classes.push('synthetic');
        if (isSelected) classes.push('highlighted');
        if (scenarioName && !isMapped && !isSelected) classes.push('dimmed');
        if (isMapped) classes.push('highlighted');

        const card = document.createElement('div');
        card.className = classes.join(' ');
        card.dataset.signalId = signal.id;

        const prob = signal.base_rate != null ? `${(signal.base_rate * 100).toFixed(0)}%` : '-';
        const resDate = signal.resolution_date ? new Date(signal.resolution_date).toLocaleDateString() : '-';

        card.innerHTML = `
          <div class="signal-header">
            <div class="signal-name">${escapeHtml(signal.text)}</div>
            <span class="source-badge ${signal.source}">${signal.source}</span>
          </div>
          <div class="signal-meta">
            <span class="signal-voi">VOI: ${signal.voi?.toFixed(2) || '-'}</span>
            <span class="signal-prob ${isObserved ? '' : 'synthetic'}">${prob}</span>
            <span>ρ: ${signal.rho?.toFixed(2) || '-'}</span>
            <span>${resDate}</span>
          </div>
          <div class="signal-rho">${escapeHtml(signal.rho_reasoning || '')}</div>
        `;

        card.addEventListener('click', () => onSignalClick(signal.id));
        container.appendChild(card);
      });
    }

    function renderScenarios(state) {
      const container = document.getElementById('scenarios-container');
      container.innerHTML = '';

      const signals = state.data.signals || [];
      const scenarios = state.data.scenarios || [];
      const { signalId, scenarioName } = state.selection;

      // Compute scenario probabilities
      const probabilities = computeScenarioProbabilities(scenarios, signals, state.resolutions);

      // Find which scenarios contain the selected signal
      let scenariosWithSignal = new Set();
      if (signalId) {
        const signalIndex = signals.findIndex(s => s.id === signalId);
        if (signalIndex >= 0) {
          scenarios.forEach(scenario => {
            const indices = getScenarioSignalIndices(scenario, signals);
            if (indices.includes(signalIndex)) {
              scenariosWithSignal.add(scenario.name);
            }
          });
        }
      }

      scenarios.forEach((scenario, idx) => {
        const isSelected = scenarioName === scenario.name;
        const isLinked = signalId && scenariosWithSignal.has(scenario.name);

        let classes = ['card', 'scenario-card'];
        if (isSelected) classes.push('highlighted');
        if (signalId && !isLinked && !isSelected) classes.push('dimmed');
        if (isLinked) classes.push('highlighted');

        const card = document.createElement('div');
        card.className = classes.join(' ');
        card.dataset.scenarioName = scenario.name;

        const prob = probabilities[idx];

        // Show scenario probability in header
        const scenarioProbPercent = (prob * 100).toFixed(0);

        card.innerHTML = `
          <div class="scenario-header">
            <span class="scenario-name">${escapeHtml(scenario.name)}</span>
            <span class="scenario-range">${scenarioProbPercent}%</span>
          </div>
          <div class="scenario-prob-bar">
            <div class="scenario-prob-fill" style="width: ${prob * 100}%"></div>
          </div>
          <div class="scenario-description">${escapeHtml(scenario.description || '')}</div>
          <div class="scenario-drivers">
            <div class="driver-label">Key Drivers:</div>
            <ul class="driver-list">
              ${(scenario.key_drivers || []).map(d => `<li>${escapeHtml(d)}</li>`).join('')}
            </ul>
          </div>
        `;

        card.addEventListener('click', () => onScenarioClick(scenario.name));
        container.appendChild(card);
      });
    }

    function renderQuestion(state) {
      const container = document.getElementById('question-container');
      container.innerHTML = '';

      const question = state.data.question;
      if (!question) return;

      const signals = state.data.signals || [];
      const scenarios = state.data.scenarios || [];
      const { signalId, scenarioName } = state.selection;

      // Compute E[X] across all scenarios (weighted by probability)
      const probabilities = computeScenarioProbabilities(scenarios, signals, state.resolutions);
      const originalProbs = computeOriginalProbabilities(scenarios, signals);

      // Check question type based on first scenario
      const isQuantitative = scenarios.some(s => s.outcome_low != null && s.outcome_high != null);
      const isBinary = scenarios.some(s => s.probability_low != null && s.probability_high != null);

      // Use unified helper for expected value computation
      const expectedValue = computeExpectedValue(scenarios, probabilities);
      const originalExpectedValue = computeExpectedValue(scenarios, originalProbs);
      const hasResolutions = Object.keys(state.resolutions).length > 0;

      const [minVal, maxVal] = question.value_range || [0, 100];
      const range = maxVal - minVal;
      const baselinePos = ((expectedValue - minVal) / range) * 100;

      const card = document.createElement('div');
      card.className = 'card question-card highlighted';

      // Build range bar content
      let rangeBarContent = '';
      let displayValue = expectedValue;
      let valueLabel = 'Expected value across all scenarios';
      let valueColorClass = '';
      let valueDeltaHtml = '';

      // Show shift from original if resolutions exist
      if (hasResolutions && !scenarioName) {
        const delta = expectedValue - originalExpectedValue;
        if (Math.abs(delta) > 0.1) {
          valueColorClass = delta > 0 ? 'positive' : 'negative';
          valueDeltaHtml = renderProbabilityShift(
            originalExpectedValue,
            expectedValue,
            (v) => formatValue(v, question.unit),
            { centered: true, deltaUnit: 'value' }
          );
          valueLabel = 'Updated expected value';
        }
      }

      if (scenarioName) {
        const scenario = scenarios.find(s => s.name === scenarioName);
        if (scenario) {
          const positions = getScenarioBarPositions(scenario, expectedValue, [minVal, maxVal]);
          if (positions) {
            displayValue = positions.midpoint;
            valueLabel = `If "${scenario.name}"`;
            valueColorClass = positions.valueColorClass;

            rangeBarContent = renderRangeBar(baselinePos, {
              baselineTitle: `E[X]: ${formatValue(expectedValue, question.unit)}`,
              scenarioPos: positions.midPos,
              scenarioLowPos: positions.lowPos,
              scenarioHighPos: positions.highPos,
              colorClass: positions.colorClass,
            });
          }
        }
      } else {
        rangeBarContent = renderRangeBar(baselinePos);
      }

      // Different display for quantitative vs binary questions
      if (isQuantitative) {
        card.innerHTML = `
          <div class="question-text">${escapeHtml(question.text)}</div>
          <div class="question-value ${valueColorClass}">${formatValue(displayValue, question.unit)}</div>
          <div class="question-label">${escapeHtml(valueLabel)}</div>
          ${valueDeltaHtml}
          <div class="question-range">
            <span>${formatValue(minVal, question.unit)}</span>
            <div class="range-bar">
              ${rangeBarContent}
            </div>
            <span>${formatValue(maxVal, question.unit)}</span>
          </div>
        `;
      } else if (isBinary) {
        // Binary question - show P(YES) with probability bar
        const pYes = expectedValue;
        const pYesPercent = (pYes * 100).toFixed(0);
        const baselinePos = pYes * 100;

        let binaryRangeBarContent = '';
        let displayProbability = pYes;
        let binaryValueLabel = 'P(YES) across all scenarios';
        let binaryColorClass = '';

        // Track if we need cruxiness labels
        let cruxinessLabelsHtml = '';

        // Handle signal selection - show cruxiness (P(YES|signal=YES) and P(YES|signal=NO))
        if (signalId) {
          const signal = signals.find(s => s.id === signalId);
          if (signal && signal.p_target_given_yes != null && signal.p_target_given_no != null) {
            const pYesGivenSignalYes = signal.p_target_given_yes;
            const pYesGivenSignalNo = signal.p_target_given_no;
            const yesPos = pYesGivenSignalYes * 100;
            const noPos = pYesGivenSignalNo * 100;
            const spread = Math.abs(yesPos - noPos);
            const spreadLeft = Math.min(yesPos, noPos);

            // Replace main display with signal context
            displayProbability = null; // Don't show a single probability
            binaryValueLabel = `If the selected signal resolves...`;

            // Build cruxiness labels - position based on which outcome has higher probability
            // Colors are semantic: YES = green (up), NO = red (down), always
            const noPercent = (pYesGivenSignalNo * 100).toFixed(0);
            const yesPercent = (pYesGivenSignalYes * 100).toFixed(0);
            const yesIsHigher = pYesGivenSignalYes >= pYesGivenSignalNo;

            // Left label is lower probability, right label is higher probability
            // YES is always green, NO is always red
            const leftLabel = yesIsHigher
              ? `<span style="color: var(--down-color);">${noPercent}% ← NO</span>`
              : `<span style="color: var(--up-color);">${yesPercent}% ← YES</span>`;
            const rightLabel = yesIsHigher
              ? `<span style="color: var(--up-color);">YES → ${yesPercent}%</span>`
              : `<span style="color: var(--down-color);">NO → ${noPercent}%</span>`;

            cruxinessLabelsHtml = `
              <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 1.1rem; font-weight: 600;">
                ${leftLabel}
                ${rightLabel}
              </div>
            `;

            // Render range bar with signal cruxiness
            const gradientDir = yesIsHigher ? 'to right' : 'to left';
            binaryRangeBarContent = renderRangeBar(baselinePos, {
              baselineTitle: `P(YES): ${pYesPercent}%`,
              yesPos,
              noPos,
              yesTitle: `If YES: ${yesPercent}%`,
              noTitle: `If NO: ${noPercent}%`,
              gradientDir,
            });
          } else {
            binaryRangeBarContent = renderRangeBar(baselinePos);
          }
        // Handle scenario selection - show comparison like continuous questions
        } else if (scenarioName) {
          const scenario = scenarios.find(s => s.name === scenarioName);
          if (scenario) {
            const positions = getScenarioBarPositions(scenario, pYes, [0, 1]);
            if (positions) {
              displayProbability = positions.midpoint;
              binaryValueLabel = `P(YES) if "${scenario.name}"`;
              binaryColorClass = positions.valueColorClass;

              binaryRangeBarContent = renderRangeBar(baselinePos, {
                baselineTitle: `P(YES): ${pYesPercent}%`,
                scenarioPos: positions.midPos,
                scenarioLowPos: positions.lowPos,
                scenarioHighPos: positions.highPos,
                colorClass: positions.colorClass,
              });
            }
          }
        } else {
          binaryRangeBarContent = renderRangeBar(baselinePos);
        }

        // Build the main value display - either probability or signal context
        let mainValueHtml;
        if (displayProbability === null) {
          // Signal selected - show context text as main display
          mainValueHtml = `
            <div class="question-label" style="font-size: 0.85rem; margin-bottom: 0.5rem; color: var(--text-secondary);">${escapeHtml(binaryValueLabel)}</div>
          `;
        } else {
          // Normal display - show probability
          mainValueHtml = `
            <div class="question-value ${binaryColorClass}" style="font-size: 2rem;">${(displayProbability * 100).toFixed(0)}% YES</div>
            <div class="question-label">${escapeHtml(binaryValueLabel)}</div>
          `;
        }

        card.innerHTML = `
          <div class="question-text">${escapeHtml(question.text)}</div>
          ${mainValueHtml}
          <div class="question-range" style="margin-top: 0.5rem;">
            <span>0%</span>
            <div class="range-bar">
              ${binaryRangeBarContent}
            </div>
            <span>100%</span>
          </div>
          ${cruxinessLabelsHtml}
        `;
      } else {
        // Fallback for questions without outcome/probability ranges
        card.innerHTML = `
          <div class="question-text">${escapeHtml(question.text)}</div>
          <div style="margin-top: 0.5rem; color: var(--text-muted); font-size: 0.7rem;">
            No quantitative data available
          </div>
        `;
      }

      container.appendChild(card);
    }

    function renderPaths(state) {
      const svg = document.getElementById('connections-svg');
      svg.innerHTML = '';

      if (!state.data) return;

      const explorerRect = document.getElementById('explorer').getBoundingClientRect();
      svg.setAttribute('viewBox', `0 0 ${explorerRect.width} ${explorerRect.height}`);

      const { signalId, scenarioName } = state.selection;
      const scenarios = state.data.scenarios || [];
      const signals = state.data.signals || [];

      // Draw signal -> scenario paths
      document.querySelectorAll('.scenario-card').forEach(scenarioCard => {
        const sName = scenarioCard.dataset.scenarioName;
        const scenario = scenarios.find(s => s.name === sName);
        if (!scenario) return;

        const scenarioRect = scenarioCard.getBoundingClientRect();

        // Get signal indices for this scenario
        const signalIndices = getScenarioSignalIndices(scenario, signals);

        signalIndices.forEach(signalIndex => {
          const matchingSignal = signals[signalIndex];
          if (!matchingSignal) return;

          const signalCard = document.querySelector(`.signal-card[data-signal-id="${matchingSignal.id}"]`);
          if (!signalCard) return;

          const signalRect = signalCard.getBoundingClientRect();

          const startX = signalRect.right - explorerRect.left;
          const startY = signalRect.top + signalRect.height / 2 - explorerRect.top;
          const endX = scenarioRect.left - explorerRect.left;
          const endY = scenarioRect.top + scenarioRect.height / 2 - explorerRect.top;
          const midX = (startX + endX) / 2;

          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
          path.setAttribute('class', 'flow-path');

          // Determine visibility - signals are neutral (can go either way based on resolution)
          const isRelevant = (signalId === matchingSignal.id) || (scenarioName === sName);

          if (signalId || scenarioName) {
            if (isRelevant) {
              path.classList.add('highlighted');
            } else {
              path.classList.add('dimmed');
            }
          }

          svg.appendChild(path);
        });
      });

      // Draw scenario -> question paths
      const questionCard = document.querySelector('.question-card');
      if (questionCard) {
        const questionRect = questionCard.getBoundingClientRect();

        // Detect question type and compute expected value
        const isQuantitative = scenarios.some(s => s.outcome_low != null && s.outcome_high != null);
        const isBinary = scenarios.some(s => s.probability_low != null && s.probability_high != null);

        // Compute E[X] or P(YES) using scenario probabilities
        const probabilities = computeScenarioProbabilities(scenarios, signals, {});
        let expectedValue = 0;
        if (scenarios.length > 0) {
          scenarios.forEach((s, i) => {
            if (isQuantitative) {
              const mid = ((s.outcome_low || 0) + (s.outcome_high || 0)) / 2;
              expectedValue += mid * probabilities[i];
            } else if (isBinary) {
              const mid = ((s.probability_low || 0) + (s.probability_high || 0)) / 2;
              expectedValue += mid * probabilities[i];
            }
          });
        }

        document.querySelectorAll('.scenario-card').forEach(scenarioCard => {
          const sName = scenarioCard.dataset.scenarioName;
          const scenario = scenarios.find(s => s.name === sName);
          const scenarioRect = scenarioCard.getBoundingClientRect();

          const startX = scenarioRect.right - explorerRect.left;
          const startY = scenarioRect.top + scenarioRect.height / 2 - explorerRect.top;
          const endX = questionRect.left - explorerRect.left;
          const endY = questionRect.top + questionRect.height / 2 - explorerRect.top;
          const midX = (startX + endX) / 2;

          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
          path.setAttribute('class', 'flow-path');

          // Determine if scenario pushes outcome up or down vs expected value
          let scenarioMid = expectedValue;
          if (scenario) {
            if (isQuantitative) {
              scenarioMid = ((scenario.outcome_low || 0) + (scenario.outcome_high || 0)) / 2;
            } else if (isBinary) {
              scenarioMid = ((scenario.probability_low || 0) + (scenario.probability_high || 0)) / 2;
            }
          }
          const isUp = scenarioMid >= expectedValue;

          // Always color the path based on direction
          path.classList.add(isUp ? 'up' : 'down');

          if (scenarioName) {
            if (scenarioName === sName) {
              path.classList.add('highlighted');
              path.setAttribute('stroke-width', 4);
            } else {
              path.classList.add('dimmed');
            }
          }

          svg.appendChild(path);
        });
      }
    }

    // =============================================================
    // Event handlers (update state, then render)
    // =============================================================

    function onSignalClick(id) {
      if (state.selection.signalId === id) {
        // Deselect
        state.selection.signalId = null;
      } else {
        state.selection.signalId = id;
        state.selection.scenarioName = null;
      }
      render(state);
    }

    function onScenarioClick(name) {
      if (state.selection.scenarioName === name) {
        // Deselect
        state.selection.scenarioName = null;
      } else {
        state.selection.scenarioName = name;
        state.selection.signalId = null;
      }
      render(state);
    }

    // =============================================================
    // Utilities
    // =============================================================

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    function computeScenarioProbabilities(scenarios, signals, resolutions = {}) {
      // E2E approach: Use LLM-estimated scenario_probability directly
      // This leverages validated conditional forecasting capability (85% direction accuracy)
      // rather than formula-based staged pipeline
      if (!scenarios || scenarios.length === 0) {
        console.warn('computeScenarioProbabilities: No scenarios');
        return [];
      }

      // Check if scenarios have LLM-estimated probabilities
      const hasScenarioProbs = scenarios.some(s => s.scenario_probability != null);

      if (hasScenarioProbs) {
        // Use LLM-estimated probabilities directly
        const probs = scenarios.map(s => s.scenario_probability || 0);

        // Normalize to ensure they sum to 1 (in case of rounding)
        const sum = probs.reduce((a, b) => a + b, 0);
        if (sum > 0) {
          return probs.map(p => p / sum);
        }
        return scenarios.map(() => 1 / scenarios.length);
      }

      // Fallback for old data without scenario_probability: uniform distribution
      console.warn('No scenario_probability found, using uniform distribution');
      return scenarios.map(() => 1 / scenarios.length);
    }

    // Compute original probabilities (no resolutions) for comparison
    function computeOriginalProbabilities(scenarios, signals) {
      return computeScenarioProbabilities(scenarios, signals, {});
    }

    function formatValue(value, unit) {
      if (unit === 'usd_trillions') return `$${value.toFixed(1)}T`;
      if (unit === 'percent') return `${value.toFixed(1)}%`;
      return value.toFixed(1);
    }

    // =============================================================
    // Data loading
    // =============================================================

    async function loadData(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to load: ${response.status}`);
        state.data = await response.json();
        state.selection = { signalId: null, scenarioName: null };
        state.resolutions = {};  // Always start with no resolutions
        render(state);
      } catch (error) {
        document.getElementById('signals-container').innerHTML = `<div class="error">${error.message}</div>`;
        console.error(error);
      }
    }

    // =============================================================
    // Initialization
    // =============================================================

    // Pretty labels for targets
    const TARGET_LABELS = {
      'gdp_2040': 'US GDP 2040',
      'gdp_2050': 'US GDP 2050',
      'gdp_2050_nocontext': 'US GDP 2050 (no context)',
      'population_2050': 'World Population 2050',
      'life_expectancy_2050': 'Life Expectancy 2050',
      'democracy_2050': 'Democracy 2050',
      'renewable_2050': 'Renewable Energy 2050',
    };

    function getTargetLabel(target) {
      return TARGET_LABELS[target] || target;
    }

    async function loadFileList() {
      try {
        const response = await fetch('/api/files');
        state.files = await response.json();
        populateTargetSelector();
      } catch (e) {
        console.error('Failed to load file list:', e);
      }
    }

    function populateTargetSelector() {
      const selector = document.getElementById('target-selector');
      selector.innerHTML = '<option value="">Select question...</option>';

      // Get unique targets
      const targets = [...new Set(state.files.map(f => f.target))];

      // Sort targets by label
      targets.sort((a, b) => getTargetLabel(a).localeCompare(getTargetLabel(b)));

      targets.forEach(target => {
        const option = document.createElement('option');
        option.value = target;
        option.textContent = getTargetLabel(target);
        selector.appendChild(option);
      });
    }

    // Normalize approach name (strip _v7 suffix)
    function normalizeApproach(approach) {
      return approach.replace(/_v\d+$/, '');
    }

    function updateApproachButtons() {
      const buttons = document.querySelectorAll('.approach-btn');
      const availableApproaches = state.files
        .filter(f => f.target === state.selectedTarget)
        .map(f => normalizeApproach(f.approach));

      buttons.forEach(btn => {
        const approach = btn.dataset.approach;
        const isAvailable = availableApproaches.includes(approach);
        btn.disabled = !isAvailable;
        btn.classList.toggle('active', approach === state.selectedApproach);
      });
    }

    function loadSelectedFile() {
      if (!state.selectedTarget || !state.selectedApproach) {
        document.getElementById('signals-container').innerHTML =
          '<div class="loading">Select a question and approach</div>';
        return;
      }

      const file = state.files.find(
        f => f.target === state.selectedTarget && normalizeApproach(f.approach) === state.selectedApproach
      );

      if (file) {
        // Update URL
        const url = new URL(window.location);
        url.searchParams.set('target', state.selectedTarget);
        url.searchParams.set('approach', state.selectedApproach);
        window.history.replaceState({}, '', url);

        loadData('../' + file.path);
      }
    }

    function init() {
      // Load file list and populate target selector
      loadFileList().then(() => {
        // Restore from URL params
        const params = new URLSearchParams(window.location.search);
        const target = params.get('target');
        const approach = params.get('approach');

        if (target) {
          state.selectedTarget = target;
          document.getElementById('target-selector').value = target;
          updateApproachButtons();

          if (approach) {
            state.selectedApproach = approach;
            updateApproachButtons();
            loadSelectedFile();
          }
        }
      });

      // Target selector
      document.getElementById('target-selector').addEventListener('change', (e) => {
        state.selectedTarget = e.target.value;
        state.selectedApproach = null;  // Reset approach when target changes
        updateApproachButtons();

        // Auto-select dual if available
        const availableApproaches = state.files
          .filter(f => f.target === state.selectedTarget)
          .map(f => normalizeApproach(f.approach));
        if (availableApproaches.includes('dual')) {
          state.selectedApproach = 'dual';
          updateApproachButtons();
          loadSelectedFile();
        } else {
          document.getElementById('signals-container').innerHTML =
            '<div class="loading">Select an approach</div>';
        }
      });

      // Approach buttons
      document.querySelectorAll('.approach-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.disabled) return;
          state.selectedApproach = btn.dataset.approach;
          updateApproachButtons();
          loadSelectedFile();
        });
      });

      // Signal sort dropdown
      document.getElementById('signal-sort').addEventListener('change', (e) => {
        state.signalSort = e.target.value;
        render(state);
      });

      // Initial state
      document.getElementById('signals-container').innerHTML =
        '<div class="loading">Select a question to explore scenarios</div>';

      // Rebuild paths on scroll/resize
      ['signals-col', 'scenarios-col', 'question-col'].forEach(id => {
        document.getElementById(id).addEventListener('scroll', () => {
          requestAnimationFrame(() => renderPaths(state));
        });
      });

      window.addEventListener('resize', () => {
        requestAnimationFrame(() => renderPaths(state));
      });
    }

    init();
  </script>
</body>
</html>
