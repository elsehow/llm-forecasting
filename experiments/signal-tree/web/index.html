<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Signal Tree Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      --bg-primary: #fafafa;
      --bg-secondary: #f5f5f5;
      --text-primary: #1a1a1a;
      --text-secondary: #525252;
      --text-muted: #a3a3a3;
      --border: #e5e5e5;
      --border-strong: #d4d4d4;

      /* Direction colors */
      --up-color: #16a34a;
      --down-color: #dc2626;

      /* Node colors */
      --node-leaf: #f0fdf4;
      --node-leaf-border: #86efac;
      --node-internal: #fefce8;
      --node-internal-border: #fde047;
      --node-root: #eff6ff;
      --node-root-border: #93c5fd;

      /* Source colors */
      --polymarket: #7c3aed;
      --metaculus: #2563eb;
      --manifold: #059669;
      --llm: #6b7280;

      /* Edge colors */
      --edge-default: #d4d4d4;
      --edge-enhances: #16a34a;
      --edge-suppresses: #dc2626;

      --radius-sm: 6px;
      --radius-md: 10px;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      background: linear-gradient(to bottom, var(--bg-primary), var(--bg-secondary));
      border-bottom: 1px solid var(--border);
      height: 56px;
    }

    .header-left { display: flex; align-items: center; gap: 1.5rem; }

    h1 {
      font-weight: 600;
      font-size: 1.25rem;
      letter-spacing: -0.025em;
    }

    .selector-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .selector-label {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .file-selector {
      padding: 0.4rem 0.75rem;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
      min-width: 180px;
    }

    .stats-bar {
      display: flex;
      gap: 1.5rem;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .stat { display: flex; align-items: center; gap: 0.25rem; }
    .stat-value { font-weight: 600; color: var(--text-secondary); font-variant-numeric: tabular-nums; }

    .reset-all-btn {
      padding: 0.3rem 0.6rem;
      font-size: 0.65rem;
      font-weight: 600;
      background: rgba(220, 38, 38, 0.1);
      color: var(--down-color);
      border: 1px solid var(--down-color);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background 0.15s;
    }
    .reset-all-btn:hover { background: rgba(220, 38, 38, 0.2); }

    /* Main layout */
    .main-container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 56px);
    }

    .content-area {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    /* Tree canvas */
    .tree-canvas {
      flex: 1;
      position: relative;
      overflow: auto;
      background: var(--bg-primary);
    }

    .tree-canvas svg {
      display: block;
      min-width: 100%;
      min-height: 100%;
    }

    /* D3 Tree styles */
    .node-group { cursor: pointer; }
    .node-group:hover .node-bg { filter: brightness(0.95); }

    .node-bg {
      stroke-width: 2;
      transition: filter 0.15s;
    }

    .node-bg.leaf {
      fill: var(--node-leaf);
      stroke: var(--node-leaf-border);
    }

    .node-bg.internal {
      fill: var(--node-internal);
      stroke: var(--node-internal-border);
    }

    .node-bg.root {
      fill: var(--node-root);
      stroke: var(--node-root-border);
    }

    .node-bg.selected {
      stroke-width: 3;
      filter: drop-shadow(0 0 8px rgba(0,0,0,0.15));
    }

    .node-bg.dimmed { opacity: 0.2; }

    .node-bg.resolved-yes {
      fill: #dcfce7;
      stroke: var(--up-color);
      stroke-width: 3;
    }

    .node-bg.resolved-no {
      fill: #fee2e2;
      stroke: var(--down-color);
      stroke-width: 3;
    }

    .node-resolution-icon {
      font-size: 14px;
      font-weight: 700;
      pointer-events: none;
    }

    .node-resolution-icon.yes { fill: var(--up-color); }
    .node-resolution-icon.no { fill: var(--down-color); }

    .node-text {
      font-size: 11px;
      font-weight: 500;
      fill: var(--text-primary);
      pointer-events: none;
    }

    .node-prob {
      font-size: 10px;
      font-weight: 600;
      fill: var(--text-secondary);
      pointer-events: none;
    }

    .node-source {
      font-size: 8px;
      font-weight: 600;
      text-transform: uppercase;
      pointer-events: none;
    }

    .node-source.polymarket { fill: var(--polymarket); }
    .node-source.metaculus { fill: var(--metaculus); }
    .node-source.llm { fill: var(--llm); }

    .link {
      fill: none;
      stroke: var(--edge-default);
      stroke-width: 2;
      transition: stroke 0.2s, stroke-width 0.2s, opacity 0.2s;
    }

    .link.enhances { stroke: var(--edge-enhances); }
    .link.suppresses { stroke: var(--edge-suppresses); }
    .link.highlighted { stroke-width: 4; }
    .link.dimmed { opacity: 0.1; }

    .link-label {
      font-size: 9px;
      font-weight: 600;
      fill: var(--text-muted);
      pointer-events: none;
    }

    .link-label.enhances { fill: var(--edge-enhances); }
    .link-label.suppresses { fill: var(--edge-suppresses); }

    /* Detail panel */
    .detail-panel {
      width: 320px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      padding: 1rem;
      display: none;
    }

    .detail-panel.visible { display: block; }

    .detail-header {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
    }

    .detail-card {
      background: var(--bg-primary);
      border-radius: var(--radius-md);
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-sm);
    }

    .signal-question {
      font-size: 0.9rem;
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 0.75rem;
    }

    .signal-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .source-badge {
      font-size: 0.6rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
      color: white;
    }

    .source-badge.polymarket { background: var(--polymarket); }
    .source-badge.metaculus { background: var(--metaculus); }
    .source-badge.llm { background: var(--llm); }

    .prob-bar {
      height: 8px;
      background: rgba(0,0,0,0.1);
      border-radius: 4px;
      overflow: hidden;
      margin: 0.5rem 0;
    }

    .prob-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }

    .prob-fill.market { background: var(--polymarket); }
    .prob-fill.llm { background: var(--llm); }

    .section-label {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin: 1rem 0 0.5rem;
    }

    .rho-display {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .rho-display.enhances { color: var(--up-color); }
    .rho-display.suppresses { color: var(--down-color); }

    .rho-reasoning {
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.5;
      font-style: italic;
    }

    /* Cruxiness bar */
    .cruxiness-section {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .cruxiness-track {
      height: 20px;
      background: var(--bg-secondary);
      border-radius: 4px;
      position: relative;
      border: 1px solid var(--border);
      margin: 0.5rem 0;
    }

    .cruxiness-spread {
      position: absolute;
      top: 3px;
      bottom: 3px;
      background: linear-gradient(to right, var(--down-color), var(--up-color));
      opacity: 0.25;
      border-radius: 2px;
    }

    .cruxiness-marker {
      position: absolute;
      top: 2px;
      bottom: 2px;
      width: 4px;
      border-radius: 2px;
      transform: translateX(-50%);
    }

    .cruxiness-marker.yes { background: var(--up-color); }
    .cruxiness-marker.no { background: var(--down-color); }
    .cruxiness-marker.baseline {
      background: var(--text-muted);
      width: 2px;
      opacity: 0.5;
    }

    .cruxiness-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .cruxiness-labels .no { color: var(--down-color); }
    .cruxiness-labels .yes { color: var(--up-color); }

    /* Path to root */
    .path-step {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      padding: 0.25rem 0;
    }

    .path-arrow {
      color: var(--text-muted);
    }

    .path-rho {
      font-size: 0.65rem;
      font-weight: 600;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }

    .path-rho.enhances {
      background: rgba(22, 163, 74, 0.1);
      color: var(--up-color);
    }

    .path-rho.suppresses {
      background: rgba(220, 38, 38, 0.1);
      color: var(--down-color);
    }

    /* What-if buttons */
    .whatif-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .whatif-btn {
      flex: 1;
      padding: 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s;
    }

    .whatif-btn.yes {
      background: rgba(22, 163, 74, 0.1);
      color: var(--up-color);
      border: 1px solid var(--up-color);
    }

    .whatif-btn.yes:hover { background: rgba(22, 163, 74, 0.2); }

    .whatif-btn.yes.active {
      background: var(--up-color);
      color: white;
    }

    .whatif-btn.no {
      background: rgba(220, 38, 38, 0.1);
      color: var(--down-color);
      border: 1px solid var(--down-color);
    }

    .whatif-btn.no:hover { background: rgba(220, 38, 38, 0.2); }

    .whatif-btn.no.active {
      background: var(--down-color);
      color: white;
    }

    .whatif-btn.reset {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .whatif-btn.reset:hover { background: var(--border); }

    /* Contribution bar (bottom) */
    .contribution-bar {
      height: 160px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      padding: 0.75rem 1.5rem;
      overflow-y: auto;
    }

    .contribution-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .contribution-title {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .contribution-list {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .contribution-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      transition: background 0.15s;
    }

    .contribution-row:hover { background: rgba(0,0,0,0.05); }
    .contribution-row.selected { background: rgba(99, 102, 241, 0.15); }

    .contribution-name {
      width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-secondary);
    }

    .contribution-bar-track {
      width: 120px;
      height: 6px;
      background: rgba(0,0,0,0.08);
      border-radius: 3px;
      overflow: hidden;
    }

    .contribution-bar-fill {
      height: 100%;
      border-radius: 3px;
    }

    .contribution-bar-fill.enhances { background: var(--up-color); }
    .contribution-bar-fill.suppresses { background: var(--down-color); }

    .contribution-value {
      width: 50px;
      text-align: right;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .contribution-value.enhances { color: var(--up-color); }
    .contribution-value.suppresses { color: var(--down-color); }

    .contribution-direction {
      width: 16px;
      text-align: center;
      font-weight: 700;
    }

    .contribution-direction.enhances { color: var(--up-color); }
    .contribution-direction.suppresses { color: var(--down-color); }

    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      background: rgba(255,255,255,0.95);
      padding: 0.75rem 1rem;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      font-size: 0.65rem;
      color: var(--text-secondary);
    }

    .legend-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
    }

    .legend-row:last-child { margin-bottom: 0; }

    .legend-swatch {
      width: 16px;
      height: 4px;
      border-radius: 2px;
    }

    .legend-swatch.enhances { background: var(--edge-enhances); }
    .legend-swatch.suppresses { background: var(--edge-suppresses); }

    .legend-node {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border-width: 2px;
      border-style: solid;
    }

    .legend-node.leaf {
      background: var(--node-leaf);
      border-color: var(--node-leaf-border);
    }

    .legend-node.internal {
      background: var(--node-internal);
      border-color: var(--node-internal-border);
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-left">
      <h1>Signal Tree Explorer</h1>
      <div class="selector-group">
        <span class="selector-label">Target</span>
        <select id="target-selector" class="file-selector">
          <option value="">Select target...</option>
        </select>
      </div>
    </div>
    <div class="stats-bar">
      <div class="stat">Signals: <span class="stat-value" id="stat-signals">-</span></div>
      <div class="stat">Leaves: <span class="stat-value" id="stat-leaves">-</span></div>
      <div class="stat">Depth: <span class="stat-value" id="stat-depth">-</span></div>
      <div class="stat">P(Target): <span class="stat-value" id="stat-prob">-</span></div>
      <button id="reset-all-btn" class="reset-all-btn" style="display: none;" onclick="resetAllResolutions()">Reset All</button>
    </div>
  </div>

  <div class="main-container">
    <div class="content-area">
      <div class="tree-canvas" id="tree-canvas">
        <svg id="tree-svg"></svg>
        <div class="legend">
          <div class="legend-row">
            <div class="legend-swatch enhances"></div>
            <span>Enhances (ρ &gt; 0)</span>
          </div>
          <div class="legend-row">
            <div class="legend-swatch suppresses"></div>
            <span>Suppresses (ρ &lt; 0)</span>
          </div>
          <div class="legend-row">
            <div class="legend-node leaf"></div>
            <span>Leaf (actionable)</span>
          </div>
          <div class="legend-row">
            <div class="legend-node internal"></div>
            <span>Internal (decomposed)</span>
          </div>
        </div>
      </div>

      <div class="detail-panel" id="detail-panel">
        <div class="detail-header">Selected Signal</div>
        <div id="detail-content"></div>
      </div>
    </div>

    <div class="contribution-bar" id="contribution-bar">
      <div class="contribution-header">
        <span class="contribution-title">Top Contributors (Leaves)</span>
      </div>
      <div class="contribution-list" id="contribution-list"></div>
    </div>
  </div>

  <script>
    // =============================================================
    // State
    // =============================================================
    const state = {
      tree: null,
      analysis: null,
      fullData: null,
      selectedNodeId: null,
      resolutions: {},  // nodeId -> 'yes' | 'no'
    };

    // =============================================================
    // Available result files
    // =============================================================
    const RESULT_FILES = [
      {
        id: 'one_battle_best_picture',
        label: 'One Battle Best Picture (Oscar)',
        path: '../results/one_battle_best_picture/tree_20260119.json',
      },
      // Add more result files here as they're generated
    ];

    // =============================================================
    // Tree rendering with D3
    // =============================================================

    function buildHierarchy(node, depth = 0) {
      // Convert our structure to D3 hierarchy format with proper depth
      const result = {
        ...node,
        depth: depth,
        children: node.children && node.children.length > 0
          ? node.children.map(child => buildHierarchy(child, depth + 1))
          : [],
      };
      // Determine if leaf (no children)
      result.is_leaf = !result.children || result.children.length === 0;
      return result;
    }

    function renderTree(treeData) {
      const svg = d3.select('#tree-svg');
      svg.selectAll('*').remove();

      const container = document.getElementById('tree-canvas');
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight - 40; // Leave room for legend

      // Build hierarchy first to calculate required size
      const hierarchy = d3.hierarchy(buildHierarchy(treeData.target));
      const nodeCount = hierarchy.descendants().length;
      const leafCount = hierarchy.leaves().length;
      const maxDepth = hierarchy.height;

      // Calculate dimensions based on tree size
      // More leaves = wider tree, more depth = taller tree
      const nodeWidth = 160;
      const nodeHeight = 60;
      const horizontalSpacing = Math.max(nodeWidth + 40, containerWidth / Math.max(leafCount, 1));
      const verticalSpacing = Math.max(nodeHeight + 80, 140);

      const margin = { top: 80, right: 100, bottom: 80, left: 100 };
      const innerWidth = Math.max(leafCount * horizontalSpacing, containerWidth - margin.left - margin.right);
      const innerHeight = Math.max((maxDepth + 1) * verticalSpacing, containerHeight - margin.top - margin.bottom);

      const width = innerWidth + margin.left + margin.right;
      const height = innerHeight + margin.top + margin.bottom;

      // Create main group with margin, enable panning via transform
      const g = svg
        .attr('width', Math.max(width, containerWidth))
        .attr('height', Math.max(height, containerHeight))
        .append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);

      // Create tree layout (top-down)
      const treeLayout = d3.tree()
        .size([innerWidth, innerHeight])
        .separation((a, b) => (a.parent === b.parent ? 1.2 : 1.8));

      const root = treeLayout(hierarchy);

      // Draw links first (so they're behind nodes)
      const links = g.selectAll('.link')
        .data(root.links())
        .enter()
        .append('path')
        .attr('class', d => {
          const rho = d.target.data.rho || 0;
          let cls = 'link';
          if (rho > 0) cls += ' enhances';
          else if (rho < 0) cls += ' suppresses';
          return cls;
        })
        .attr('d', d3.linkVertical()
          .x(d => d.x)
          .y(d => d.y)
        )
        .attr('stroke-width', d => {
          const rho = Math.abs(d.target.data.rho || 0);
          return 1.5 + rho * 3; // 1.5 to 4.5
        })
        .attr('data-source', d => d.source.data.id)
        .attr('data-target', d => d.target.data.id);

      // Add rho labels on links
      g.selectAll('.link-label')
        .data(root.links().filter(d => d.target.data.rho != null))
        .enter()
        .append('text')
        .attr('class', d => {
          const rho = d.target.data.rho || 0;
          let cls = 'link-label';
          if (rho > 0) cls += ' enhances';
          else if (rho < 0) cls += ' suppresses';
          return cls;
        })
        .attr('x', d => (d.source.x + d.target.x) / 2)
        .attr('y', d => (d.source.y + d.target.y) / 2 - 5)
        .attr('text-anchor', 'middle')
        .text(d => `ρ=${d.target.data.rho > 0 ? '+' : ''}${d.target.data.rho.toFixed(2)}`);

      // Draw nodes
      const nodeW = 160;
      const nodeH = 55;

      const nodes = g.selectAll('.node-group')
        .data(root.descendants())
        .enter()
        .append('g')
        .attr('class', 'node-group')
        .attr('transform', d => `translate(${d.x}, ${d.y})`)
        .attr('data-id', d => d.data.id)
        .on('click', (event, d) => onNodeClick(d.data.id));

      // Add invisible rect for better hover/click target + tooltip
      nodes.append('title')
        .text(d => {
          const prob = d.data.base_rate != null ? `${(d.data.base_rate * 100).toFixed(0)}%` : '-';
          const rho = d.data.rho != null ? `ρ=${d.data.rho > 0 ? '+' : ''}${d.data.rho.toFixed(2)}` : '';
          return `${d.data.text}\n\nP(YES): ${prob}${rho ? '\n' + rho : ''}`;
        });

      // Node background rectangles
      nodes.append('rect')
        .attr('class', d => {
          let cls = 'node-bg';
          if (d.depth === 0) cls += ' root';
          else if (d.data.is_leaf) cls += ' leaf';
          else cls += ' internal';
          // Add resolution state
          const resolution = state.resolutions[d.data.id];
          if (resolution === 'yes') cls += ' resolved-yes';
          else if (resolution === 'no') cls += ' resolved-no';
          return cls;
        })
        .attr('x', -nodeW / 2)
        .attr('y', -nodeH / 2)
        .attr('width', nodeW)
        .attr('height', nodeH)
        .attr('rx', 8);

      // Node text (truncated)
      nodes.append('text')
        .attr('class', 'node-text')
        .attr('y', -8)
        .attr('text-anchor', 'middle')
        .text(d => truncate(d.data.text, 24));

      // Probability (show resolved or computed value)
      nodes.append('text')
        .attr('class', 'node-prob')
        .attr('y', 8)
        .attr('text-anchor', 'middle')
        .text(d => {
          const resolution = state.resolutions[d.data.id];
          if (resolution === 'yes') return '100%';
          if (resolution === 'no') return '0%';
          // Use computed probability if available (for internal nodes after resolution)
          const computedProb = state.computedWithResolutions?.[d.data.id];
          const prob = computedProb ?? d.data.base_rate;
          return prob != null ? `${(prob * 100).toFixed(0)}%` : '-';
        });

      // Source badge
      nodes.filter(d => d.data.probability_source)
        .append('text')
        .attr('class', d => `node-source ${d.data.probability_source}`)
        .attr('y', 20)
        .attr('text-anchor', 'middle')
        .text(d => d.data.probability_source);

      // Resolution icons (checkmark or X)
      nodes.filter(d => state.resolutions[d.data.id])
        .append('text')
        .attr('class', d => `node-resolution-icon ${state.resolutions[d.data.id]}`)
        .attr('x', nodeW / 2 - 12)
        .attr('y', -nodeH / 2 + 16)
        .attr('text-anchor', 'middle')
        .text(d => state.resolutions[d.data.id] === 'yes' ? '✓' : '✗');

      // Update stats
      updateStats(treeData);
    }

    function truncate(text, maxLen) {
      if (!text) return '';
      return text.length > maxLen ? text.slice(0, maxLen - 1) + '…' : text;
    }

    function updateStats(treeData) {
      // Use tree metadata or analysis data
      const analysis = state.analysis;

      const totalSignals = analysis?.total_signals ?? treeData.signals?.length ?? countNodes(treeData.target);
      const leafCount = analysis?.leaf_count ?? treeData.leaf_count ?? 0;
      const maxDepth = analysis?.max_depth ?? treeData.max_depth ?? 0;

      // Use recomputed probability if we have resolutions, otherwise original
      const originalProb = analysis?.computed_probability ?? treeData.computed_probability;
      const hasResolutions = Object.keys(state.resolutions).length > 0;
      const currentProb = hasResolutions
        ? treeData.computed_probability_with_resolutions
        : originalProb;

      document.getElementById('stat-signals').textContent = totalSignals;
      document.getElementById('stat-leaves').textContent = leafCount;
      document.getElementById('stat-depth').textContent = maxDepth;

      // Show probability with delta if changed
      const probEl = document.getElementById('stat-prob');
      if (currentProb != null) {
        const currentPct = (currentProb * 100).toFixed(0);
        if (hasResolutions && originalProb != null) {
          const delta = currentProb - originalProb;
          const deltaPct = (delta * 100).toFixed(0);
          const deltaSign = delta >= 0 ? '+' : '';
          const deltaColor = delta >= 0 ? 'var(--up-color)' : 'var(--down-color)';
          probEl.innerHTML = `${currentPct}% <span style="color: ${deltaColor}; font-size: 0.6rem;">(${deltaSign}${deltaPct}pp)</span>`;
        } else {
          probEl.textContent = `${currentPct}%`;
        }
      } else {
        probEl.textContent = '-';
      }
    }

    function countNodes(node) {
      let count = node.children ? node.children.length : 0;
      if (node.children) {
        node.children.forEach(child => count += countNodes(child));
      }
      return count;
    }

    // =============================================================
    // Node selection and highlighting
    // =============================================================

    function onNodeClick(nodeId) {
      if (state.selectedNodeId === nodeId) {
        // Deselect
        state.selectedNodeId = null;
        clearHighlights();
        hideDetailPanel();
      } else {
        state.selectedNodeId = nodeId;
        highlightPath(nodeId);
        showDetailPanel(nodeId);
      }
      updateContributionHighlight();
    }

    function clearHighlights() {
      d3.selectAll('.node-bg').classed('selected', false).classed('dimmed', false);
      d3.selectAll('.link').classed('highlighted', false).classed('dimmed', false);
    }

    function highlightPath(nodeId) {
      clearHighlights();

      // Find the node and its path to root
      const pathIds = new Set();
      const findPath = (node, targetId, path = []) => {
        path.push(node.id);
        if (node.id === targetId) {
          path.forEach(id => pathIds.add(id));
          return true;
        }
        if (node.children) {
          for (const child of node.children) {
            if (findPath(child, targetId, [...path])) return true;
          }
        }
        return false;
      };
      findPath(state.tree.target, nodeId);

      // Highlight nodes on path, dim others
      d3.selectAll('.node-group').each(function(d) {
        const bg = d3.select(this).select('.node-bg');
        if (pathIds.has(d.data.id)) {
          bg.classed('selected', d.data.id === nodeId);
        } else {
          bg.classed('dimmed', true);
        }
      });

      // Highlight links on path
      d3.selectAll('.link').each(function(d) {
        const link = d3.select(this);
        if (pathIds.has(d.source.data.id) && pathIds.has(d.target.data.id)) {
          link.classed('highlighted', true);
        } else {
          link.classed('dimmed', true);
        }
      });
    }

    // =============================================================
    // Detail panel
    // =============================================================

    function findNode(node, targetId) {
      if (node.id === targetId) return node;
      if (node.children) {
        for (const child of node.children) {
          const found = findNode(child, targetId);
          if (found) return found;
        }
      }
      return null;
    }

    function getPathToRoot(nodeId) {
      const path = [];
      const findPath = (node, targetId, currentPath = []) => {
        currentPath.push(node);
        if (node.id === targetId) {
          path.push(...currentPath);
          return true;
        }
        if (node.children) {
          for (const child of node.children) {
            if (findPath(child, targetId, [...currentPath])) return true;
          }
        }
        return false;
      };
      findPath(state.tree.target, nodeId);
      return path.reverse(); // From node to root
    }

    function showDetailPanel(nodeId) {
      const panel = document.getElementById('detail-panel');
      const content = document.getElementById('detail-content');
      const node = findNode(state.tree.target, nodeId);

      if (!node) return;

      const isRoot = node.id === 'target';
      const prob = node.base_rate != null ? (node.base_rate * 100).toFixed(0) : '-';
      const source = node.probability_source || 'unknown';
      const resDate = node.resolution_date
        ? new Date(node.resolution_date).toLocaleDateString()
        : '-';

      let html = `
        <div class="detail-card">
          <div class="signal-question">${escapeHtml(node.text)}</div>
          <div class="signal-meta">
            <span class="source-badge ${source}">${source}</span>
            <span>Resolves: ${resDate}</span>
          </div>
          <div style="font-size: 1.5rem; font-weight: 700; margin: 0.5rem 0;">${prob}%</div>
          <div class="prob-bar">
            <div class="prob-fill ${source === 'llm' ? 'llm' : 'market'}"
                 style="width: ${prob}%"></div>
          </div>
        </div>
      `;

      // Relationship to parent (if not root)
      if (!isRoot && node.rho != null) {
        const rhoClass = node.rho > 0 ? 'enhances' : 'suppresses';
        const rhoLabel = node.rho > 0 ? 'Enhances' : 'Suppresses';
        html += `
          <div class="section-label">Relationship to Parent</div>
          <div class="detail-card">
            <div class="rho-display ${rhoClass}">
              ${rhoLabel} &nbsp; ρ = ${node.rho > 0 ? '+' : ''}${node.rho.toFixed(2)}
            </div>
            ${node.rho_reasoning ? `<div class="rho-reasoning">"${escapeHtml(node.rho_reasoning)}"</div>` : ''}
          </div>
        `;
      }

      // Cruxiness (impact on parent)
      if (node.p_parent_given_yes != null && node.p_parent_given_no != null) {
        const pYes = (node.p_parent_given_yes * 100).toFixed(0);
        const pNo = (node.p_parent_given_no * 100).toFixed(0);
        const spread = Math.abs(node.p_parent_given_yes - node.p_parent_given_no) * 100;

        // Calculate positions (scale 0-100%)
        const yesPos = node.p_parent_given_yes * 100;
        const noPos = node.p_parent_given_no * 100;
        const spreadLeft = Math.min(yesPos, noPos);
        const spreadWidth = Math.abs(yesPos - noPos);

        // Find parent for context
        const parent = findNode(state.tree.target, node.parent_id);
        const parentName = parent ? truncate(parent.text, 30) : 'parent';
        const parentBaseline = parent?.base_rate != null ? parent.base_rate * 100 : 50;

        html += `
          <div class="section-label">Impact on Parent</div>
          <div class="detail-card cruxiness-section" style="border-top: none; margin-top: 0; padding-top: 0;">
            <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
              P("${escapeHtml(parentName)}") if this resolves...
            </div>
            <div class="cruxiness-track">
              <div class="cruxiness-spread" style="left: ${spreadLeft}%; width: ${spreadWidth}%;"></div>
              <div class="cruxiness-marker baseline" style="left: ${parentBaseline}%;" title="Current P(parent)"></div>
              <div class="cruxiness-marker no" style="left: ${noPos}%;"></div>
              <div class="cruxiness-marker yes" style="left: ${yesPos}%;"></div>
            </div>
            <div class="cruxiness-labels">
              <span class="no">NO → ${pNo}%</span>
              <span class="yes">YES → ${pYes}%</span>
            </div>
            <div style="text-align: center; margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">
              Spread: ${spread.toFixed(0)}pp
            </div>
          </div>
        `;
      }

      // Path to root
      if (!isRoot) {
        const path = getPathToRoot(nodeId);
        let pathHtml = '';
        for (let i = 0; i < path.length - 1; i++) {
          const current = path[i];
          const next = path[i + 1];
          const rho = current.rho;
          const rhoClass = rho > 0 ? 'enhances' : 'suppresses';
          pathHtml += `
            <div class="path-step">
              <span>${truncate(current.text, 25)}</span>
              ${rho != null ? `<span class="path-rho ${rhoClass}">ρ=${rho > 0 ? '+' : ''}${rho.toFixed(2)}</span>` : ''}
              <span class="path-arrow">→</span>
            </div>
          `;
        }
        pathHtml += `<div class="path-step"><span>${truncate(path[path.length - 1].text, 25)}</span></div>`;

        html += `
          <div class="section-label">Path to Root</div>
          <div class="detail-card">
            ${pathHtml}
          </div>
        `;
      }

      // What-if buttons (for leaves)
      if (node.is_leaf) {
        const resolution = state.resolutions[nodeId];
        html += `
          <div class="section-label">What-If Analysis</div>
          <div class="detail-card" style="padding: 0.75rem;">
            <div class="whatif-buttons" style="margin-top: 0;">
              <button class="whatif-btn yes ${resolution === 'yes' ? 'active' : ''}"
                      onclick="resolveSignal('${nodeId}', ${resolution === 'yes' ? 'null' : "'yes'"})">
                ${resolution === 'yes' ? '✓ ' : ''}YES
              </button>
              <button class="whatif-btn no ${resolution === 'no' ? 'active' : ''}"
                      onclick="resolveSignal('${nodeId}', ${resolution === 'no' ? 'null' : "'no'"})">
                ${resolution === 'no' ? '✗ ' : ''}NO
              </button>
            </div>
            ${resolution ? `
              <div style="text-align: center; margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">
                Click active button to reset
              </div>
            ` : `
              <div style="text-align: center; margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">
                Resolve this signal to see impact on target
              </div>
            `}
          </div>
        `;
      }

      content.innerHTML = html;
      panel.classList.add('visible');
    }

    function hideDetailPanel() {
      document.getElementById('detail-panel').classList.remove('visible');
    }

    function resolveSignal(nodeId, resolution) {
      if (resolution) {
        state.resolutions[nodeId] = resolution;
      } else {
        delete state.resolutions[nodeId];
      }

      // Recompute probabilities with resolutions
      recomputeProbabilities();

      // Re-render tree to show resolution state
      renderTree(state.tree);

      // Re-highlight selected node if any
      if (state.selectedNodeId) {
        highlightPath(state.selectedNodeId);
      }

      // Re-render detail panel
      showDetailPanel(nodeId);

      // Update stats and reset button
      updateStats(state.tree);
      updateResetButton();
    }

    // =============================================================
    // Probability recomputation (mirrors rollup.py logic)
    // =============================================================

    function recomputeProbabilities() {
      if (!state.tree) return;

      // Reset computed probabilities
      state.computedWithResolutions = {};

      // Compute from leaves up (recursive, stores all computed values)
      const computeNodeProb = (node, prior = 0.5) => {
        // If this node is resolved, return 1.0 or 0.0
        const resolution = state.resolutions[node.id];
        if (resolution === 'yes') {
          state.computedWithResolutions[node.id] = 1.0;
          return 1.0;
        }
        if (resolution === 'no') {
          state.computedWithResolutions[node.id] = 0.0;
          return 0.0;
        }

        // If leaf (no children), use base_rate
        if (!node.children || node.children.length === 0) {
          const prob = node.base_rate ?? prior;
          state.computedWithResolutions[node.id] = prob;
          return prob;
        }

        // Compute from children using log-odds model
        let logOdds = Math.log(prior / (1 - prior));
        const k = 2.0; // Scaling factor

        for (const child of node.children) {
          const childProb = computeNodeProb(child, 0.5);
          const childRho = child.rho ?? 0;

          // Contribution: rho * (p - 0.5)
          const contribution = childRho * (childProb - 0.5) * k;
          logOdds += contribution;
        }

        // Convert back to probability
        const prob = 1 / (1 + Math.exp(-logOdds));
        const clampedProb = Math.max(0.01, Math.min(0.99, prob));

        // Store computed prob for THIS node (important for internal nodes!)
        state.computedWithResolutions[node.id] = clampedProb;
        return clampedProb;
      };

      // Compute target probability (this recursively computes all nodes)
      const targetProb = computeNodeProb(state.tree.target, state.analysis?.target_prior ?? 0.5);

      // Update the displayed computed probability
      state.tree.computed_probability_with_resolutions = targetProb;
    }

    function getDisplayProbability(nodeId) {
      // If we have a resolution-adjusted probability, use it
      if (state.computedWithResolutions && state.computedWithResolutions[nodeId] != null) {
        return state.computedWithResolutions[nodeId];
      }
      // Otherwise return original base_rate
      const node = findNode(state.tree.target, nodeId);
      return node?.base_rate;
    }

    function resetAllResolutions() {
      state.resolutions = {};
      state.computedWithResolutions = {};
      delete state.tree.computed_probability_with_resolutions;

      // Re-render
      renderTree(state.tree);
      renderContributions(state.tree, state.analysis);
      updateStats(state.tree);
      updateResetButton();

      // Clear selection
      state.selectedNodeId = null;
      hideDetailPanel();
    }

    function updateResetButton() {
      const btn = document.getElementById('reset-all-btn');
      const hasResolutions = Object.keys(state.resolutions).length > 0;
      btn.style.display = hasResolutions ? 'block' : 'none';
    }

    // =============================================================
    // Contribution bar
    // =============================================================

    function renderContributions(treeData, analysisData) {
      const container = document.getElementById('contribution-list');

      // Use pre-computed contributions from analysis if available
      let contributions = [];
      if (analysisData && analysisData.top_contributors) {
        contributions = analysisData.top_contributors.slice(0, 6);
      } else {
        // Fallback: compute from tree
        const collectLeaves = (node) => {
          if (node.is_leaf) {
            const baseRate = node.base_rate ?? 0.5;
            const rho = node.rho ?? 0;
            const contribution = Math.abs(rho) * Math.abs(baseRate - 0.5);
            contributions.push({
              signal_id: node.id,
              text: node.text,
              contribution,
              rho,
              base_rate: baseRate,
              direction: rho > 0 ? 'enhances' : 'suppresses',
            });
          }
          if (node.children) {
            node.children.forEach(collectLeaves);
          }
        };
        collectLeaves(treeData.target);
        contributions.sort((a, b) => b.contribution - a.contribution);
        contributions = contributions.slice(0, 6);
      }

      const maxContrib = contributions.length > 0 ? contributions[0].contribution : 0;

      container.innerHTML = contributions.map(c => {
        const direction = c.direction || (c.rho > 0 ? 'enhances' : 'suppresses');
        const arrow = direction === 'enhances' ? '↑' : '↓';
        const barWidth = maxContrib > 0 ? (c.contribution / maxContrib) * 100 : 0;
        const contribPercent = (c.contribution * 100).toFixed(1);

        return `
          <div class="contribution-row" data-id="${c.signal_id}" onclick="onContributionClick('${c.signal_id}')">
            <span class="contribution-name">${escapeHtml(truncate(c.text, 45))}</span>
            <div class="contribution-bar-track">
              <div class="contribution-bar-fill ${direction}" style="width: ${barWidth}%"></div>
            </div>
            <span class="contribution-value ${direction}">${direction === 'enhances' ? '+' : '−'}${contribPercent}%</span>
            <span class="contribution-direction ${direction}">${arrow}</span>
          </div>
        `;
      }).join('');
    }

    function onContributionClick(nodeId) {
      onNodeClick(nodeId);
    }

    function updateContributionHighlight() {
      document.querySelectorAll('.contribution-row').forEach(row => {
        row.classList.toggle('selected', row.dataset.id === state.selectedNodeId);
      });
    }

    // =============================================================
    // Utilities
    // =============================================================

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // =============================================================
    // Data loading
    // =============================================================

    async function loadTreeData(filePath) {
      try {
        const response = await fetch(filePath);
        if (!response.ok) throw new Error(`Failed to load: ${response.status}`);
        const data = await response.json();

        // The file has { config, tree, analysis, generated_at }
        // tree has { target, signals, max_depth, leaf_count, ... }
        state.fullData = data;
        state.tree = data.tree;
        state.analysis = data.analysis;

        // Clear selection
        state.selectedNodeId = null;
        state.resolutions = {};

        renderTree(state.tree);
        renderContributions(state.tree, state.analysis);
        hideDetailPanel();

      } catch (error) {
        console.error('Failed to load tree data:', error);
        document.getElementById('tree-canvas').innerHTML = `
          <div class="empty-state">
            <p>Error loading data: ${error.message}</p>
          </div>
        `;
      }
    }

    // =============================================================
    // Initialization
    // =============================================================

    function init() {
      // Populate selector with available files
      const selector = document.getElementById('target-selector');
      selector.innerHTML = '<option value="">Select target...</option>' +
        RESULT_FILES.map(f => `<option value="${f.path}">${f.label}</option>`).join('');

      // Handle selector change
      selector.addEventListener('change', (e) => {
        if (e.target.value) {
          loadTreeData(e.target.value);
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (state.tree) {
          renderTree(state.tree);
          if (state.selectedNodeId) {
            highlightPath(state.selectedNodeId);
          }
        }
      });

      // Auto-load first file if available
      if (RESULT_FILES.length > 0) {
        selector.value = RESULT_FILES[0].path;
        loadTreeData(RESULT_FILES[0].path);
      }
    }

    init();
  </script>
</body>
</html>
