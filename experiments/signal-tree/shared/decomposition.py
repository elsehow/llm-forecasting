"""Recursive signal decomposition."""

from __future__ import annotations

import uuid
from datetime import date, timedelta

import litellm
from pydantic import BaseModel, Field

from .tree import SignalNode, SignalTree, TreeGenerationConfig


class GeneratedSignal(BaseModel):
    """A signal generated by the LLM."""

    text: str = Field(description="The signal question text")
    resolution_date: str = Field(description="Expected resolution date (YYYY-MM-DD)")
    base_rate_estimate: float = Field(
        description="Estimated probability (0-1)", ge=0, le=1
    )
    reasoning: str = Field(description="Why this signal informs the parent")


class SignalGenerationResponse(BaseModel):
    """Response from signal generation."""

    signals: list[GeneratedSignal]


SIGNAL_GENERATION_PROMPT = """You are generating signals that would inform the probability of a target question.

TARGET QUESTION: "{target}"
{context_section}
Generate {n} signals that would help predict the outcome of this target question.

Requirements for each signal:
1. **Resolvable**: Must have a clear YES/NO outcome with specific criteria
2. **Time-bound**: Must resolve BEFORE the target question
3. **Resolution date**: Should resolve within {horizon_days} days of today ({today})
4. **Informative**: Learning the signal's outcome should meaningfully update P(target)

For each signal, consider:
- What would make the target MORE likely if this signal resolves YES?
- What would make the target LESS likely if this signal resolves YES?
- Include BOTH types of signals (some that help if YES, some that hurt if YES)

IMPORTANT: Consider whether signals are COMPETITORS to the target:
- If target is "Will X win?" and signal is "Will Y be nominated?", Y being nominated is COMPETITION
- Competition signals should have NEGATIVE correlation with target

Respond with a list of {n} signals, each with:
- text: The signal question (specific, resolvable)
- resolution_date: YYYY-MM-DD format, within {horizon_days} days
- base_rate_estimate: Your estimate of P(signal=YES)
- reasoning: Why this signal informs the target
"""


async def generate_signals_for_node(
    parent: SignalNode,
    config: TreeGenerationConfig,
    today: date | None = None,
) -> list[SignalNode]:
    """Generate child signals for a parent node.

    Args:
        parent: The parent node to generate signals for
        config: Generation configuration
        today: Current date (defaults to today)

    Returns:
        List of generated SignalNode objects
    """
    today = today or date.today()

    # Build context section if provided
    context_section = ""
    if config.target_context:
        context_section = f"\nCONTEXT:\n{config.target_context}\n"

    response = await litellm.acompletion(
        model=config.generation_model,
        messages=[
            {
                "role": "user",
                "content": SIGNAL_GENERATION_PROMPT.format(
                    target=parent.text,
                    context_section=context_section,
                    n=config.signals_per_node,
                    horizon_days=config.actionable_horizon_days,
                    today=today.isoformat(),
                ),
            }
        ],
        response_format=SignalGenerationResponse,
    )

    result = SignalGenerationResponse.model_validate_json(
        response.choices[0].message.content
    )

    # Convert to SignalNode objects
    signals = []
    for gen_signal in result.signals:
        try:
            res_date = date.fromisoformat(gen_signal.resolution_date)
        except ValueError:
            res_date = today + timedelta(days=config.actionable_horizon_days // 2)

        signal = SignalNode(
            id=f"sig_{uuid.uuid4().hex[:8]}",
            text=gen_signal.text,
            resolution_date=res_date,
            base_rate=gen_signal.base_rate_estimate,
            probability_source="llm",
            parent_id=parent.id,
            depth=parent.depth + 1,
        )
        signals.append(signal)

    return signals


def needs_decomposition(
    signal: SignalNode,
    config: TreeGenerationConfig,
    today: date | None = None,
    current_signal_count: int = 0,
) -> bool:
    """Check if a signal needs further decomposition.

    Resolution-based termination:
    - Primary rule: Stop when signal resolves within minimum_resolution_days
    - Safety valve: Stop if tree already has max_signals

    Args:
        signal: The signal to check
        config: Generation configuration
        today: Current date
        current_signal_count: Current total signals in tree (for max_signals check)

    Returns:
        True if the signal should be decomposed further
    """
    today = today or date.today()

    # Safety valve: check max_signals budget
    if current_signal_count >= config.max_signals:
        return False

    # Check resolution date
    if signal.resolution_date is None:
        # Unknown date, assume needs decomposition
        return True

    # Primary rule: stop if resolves within minimum_resolution_days
    min_date = today + timedelta(days=config.minimum_resolution_days)
    return signal.resolution_date > min_date


async def build_signal_tree(
    config: TreeGenerationConfig,
    today: date | None = None,
) -> SignalTree:
    """Build a complete signal tree for a target question.

    Recursively generates signals until all leaves resolve within
    minimum_resolution_days or max_signals budget is exhausted.

    Args:
        config: Generation configuration
        today: Current date

    Returns:
        Complete SignalTree
    """
    from llm_forecasting.voi import estimate_rho_two_step_batch

    today = today or date.today()

    # Create root node
    root = SignalNode(
        id=config.target_id,
        text=config.target_question,
        depth=0,
        is_leaf=False,  # Will have children
    )

    # Track all signals
    all_signals: list[SignalNode] = []

    # Queue of nodes to process (BFS)
    queue: list[SignalNode] = [root]

    while queue:
        # Check budget before generating more signals
        if len(all_signals) >= config.max_signals:
            # Mark all remaining queued nodes as leaves
            for node in queue:
                node.is_leaf = True
            break

        current = queue.pop(0)

        # Generate children for current node
        children = await generate_signals_for_node(current, config, today)

        for child in children:
            all_signals.append(child)

            # Check if child needs decomposition (pass current count)
            if needs_decomposition(child, config, today, len(all_signals)):
                child.is_leaf = False
                queue.append(child)
            else:
                child.is_leaf = True

        # Update current node's children list
        current.children = children

    # Estimate rho for all signals
    if all_signals:
        pairs = []
        for signal in all_signals:
            parent = root if signal.parent_id == root.id else next(
                (s for s in all_signals if s.id == signal.parent_id), root
            )
            pairs.append((parent.text, signal.text))

        print(f"  Estimating rho for {len(pairs)} signal pairs (two-step)...")
        rho_results = await estimate_rho_two_step_batch(pairs)

        for signal, (rho, reasoning) in zip(all_signals, rho_results):
            signal.rho = rho
            signal.rho_reasoning = reasoning

    # Build tree
    tree = SignalTree(
        target=root,
        signals=all_signals,
        max_depth=max((s.depth for s in all_signals), default=0),
        leaf_count=sum(1 for s in all_signals if s.is_leaf),
        actionable_horizon_days=config.actionable_horizon_days,
    )

    return tree
