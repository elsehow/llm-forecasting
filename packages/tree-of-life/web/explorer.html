<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tree of Life</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #fafafa;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #eeeeee;
      --text-primary: #1a1a1a;
      --text-secondary: #525252;
      --text-muted: #a3a3a3;
      --accent-primary: #2563eb;
      --accent-secondary: #7c3aed;
      --success: #16a34a;
      --warning: #ea580c;
      --error: #dc2626;
      --border: #e5e5e5;
      --border-strong: #d4d4d4;

      --signal-bg: #f0fdf4;
      --signal-border: #86efac;
      --signal-text: #166534;
      --signal-highlight: #dcfce7;

      --scenario-bg: #fffbeb;
      --scenario-border: #fcd34d;
      --scenario-text: #92400e;
      --scenario-highlight: #fef3c7;

      --question-bg: #eff6ff;
      --question-border: #93c5fd;
      --question-text: #1e40af;
      --question-highlight: #dbeafe;

      --flow-color: rgba(245, 158, 11, 0.2);
      --flow-highlight: rgba(245, 158, 11, 0.6);
      --up-color: #16a34a;
      --down-color: #dc2626;

      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    .header {
      text-align: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(to bottom, var(--bg-primary), var(--bg-secondary));
      border-bottom: 1px solid var(--border);
    }

    h1 {
      font-weight: 600;
      font-size: 1.5rem;
      letter-spacing: -0.025em;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 400;
    }

    .stats-bar {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      padding: 0.5rem 1rem;
      background: var(--bg-secondary);
      font-size: 0.7rem;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }
    .stat { display: flex; align-items: center; gap: 0.25rem; }
    .stat-value { font-weight: 600; color: var(--text-secondary); font-variant-numeric: tabular-nums; }

    .explorer-container { position: relative; height: calc(100vh - 95px); overflow: hidden; }
    .explorer { display: grid; grid-template-columns: 300px 1fr 300px; gap: 0; height: 100%; position: relative; }

    .column {
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 0.75rem;
      background: var(--bg-primary);
      min-height: 0; /* Required for overflow scroll in grid children */
    }

    .column::-webkit-scrollbar { width: 6px; }
    .column::-webkit-scrollbar-track { background: transparent; }
    .column::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 3px; }
    .column::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    .column-header {
      text-align: center;
      font-size: 0.65rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      padding: 0.5rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 0.5rem;
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      z-index: 10;
    }

    .cards-container { display: flex; flex-direction: column; gap: 0.35rem; }

    .scenarios-column {
      background: var(--bg-secondary);
      width: 460px;
      min-width: 460px;
      margin: 0 auto;
    }
    .scenarios-column .column-header { background: var(--bg-secondary); }

    .card {
      padding: 0.5rem 0.65rem;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1.5px solid transparent;
      position: relative;
      box-shadow: var(--shadow-sm);
    }
    .card:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    .card.dimmed { opacity: 0.2; }
    .card.highlighted {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    .signal-card {
      background: var(--signal-bg);
      border-color: var(--signal-border);
      color: var(--signal-text);
      font-size: 0.7rem;
      line-height: 1.4;
    }
    .signal-card.highlighted {
      border-color: var(--signal-text);
      background: var(--signal-highlight);
    }
    .signal-name {
      font-weight: 500;
      margin-bottom: 0.15rem;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .signal-card.highlighted .signal-name {
      -webkit-line-clamp: unset;
      overflow: visible;
    }
    .signal-effects { display: none; flex-wrap: wrap; gap: 0.2rem; margin-top: 0.35rem; }
    .signal-card.show-expanded .signal-effects { display: flex; }
    .effect-tag {
      font-size: 0.55rem;
      padding: 0.15rem 0.35rem;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      gap: 0.15rem;
      font-weight: 500;
    }
    .effect-tag.up { background: rgba(22, 163, 74, 0.12); color: var(--up-color); }
    .effect-tag.down { background: rgba(220, 38, 38, 0.12); color: var(--down-color); }
    .effect-arrow { font-size: 0.65rem; }

    .scenario-card {
      background: var(--scenario-bg);
      border-color: var(--scenario-border);
      color: var(--scenario-text);
      width: 100%;
    }
    .scenario-card.highlighted {
      border-color: var(--scenario-text);
      background: var(--scenario-highlight);
    }
    .scenario-name {
      font-weight: 600;
      font-size: 0.72rem;
      margin-bottom: 0.1rem;
      line-height: 1.25;
    }
    .scenario-prob {
      font-size: 0.9rem;
      color: var(--accent-primary);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }
    .scenario-bar {
      height: 3px;
      background: var(--border);
      border-radius: 2px;
      margin-top: 0.25rem;
      overflow: hidden;
    }
    .scenario-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      border-radius: 2px;
    }
    .scenario-desc {
      font-size: 0.72rem;
      color: var(--text-secondary);
      margin-top: 0.5rem;
      line-height: 1.5;
      display: none;
      border-top: 1px solid var(--border);
      padding-top: 0.4rem;
    }
    .scenario-card.show-expanded .scenario-desc { display: block; }

    .question-card {
      background: var(--question-bg);
      border-color: var(--question-border);
      color: var(--question-text);
    }
    .question-card.highlighted {
      border-color: var(--question-text);
      background: var(--question-highlight);
    }
    .question-name {
      font-size: 0.7rem;
      font-weight: 500;
      line-height: 1.3;
    }
    .question-domain {
      font-size: 0.55rem;
      color: var(--text-muted);
      margin-top: 0.15rem;
      letter-spacing: 0.05em;
      font-weight: 500;
    }
    .question-outcome {
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--accent-primary);
      margin-top: 0.3rem;
      display: none;
      font-variant-numeric: tabular-nums;
    }
    .question-outcome.negative { color: var(--down-color); }
    .question-outcome.positive { color: var(--up-color); }
    .question-card.highlighted .question-outcome { display: block; }
    .question-ci {
      font-size: 0.6rem;
      color: var(--text-muted);
      display: none;
      font-variant-numeric: tabular-nums;
    }
    .question-card.highlighted .question-ci { display: block; }

    .connections-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    .flow-path {
      fill: none;
      stroke: var(--flow-color);
      opacity: 0;
    }
    .flow-path.highlighted {
      stroke: var(--flow-highlight);
      opacity: 1;
    }
    .flow-path.dimmed {
      opacity: 0;
    }
    .flow-path.up { stroke: rgba(22, 163, 74, 0.5); }
    .flow-path.down { stroke: rgba(220, 38, 38, 0.5); }
    .flow-path.outcome-up { stroke: rgba(22, 163, 74, 0.6); }
    .flow-path.outcome-down { stroke: rgba(220, 38, 38, 0.6); }

    .loading {
      text-align: center;
      padding: 4rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Tree of Life</h1>
    <p class="subtitle">Click on signals, scenarios, and outcomes to see how they affect one another.</p>
  </div>
  <div class="stats-bar">
    <div class="stat"><span class="stat-value" id="signal-count">-</span> signals</div>
    <div class="stat"><span class="stat-value" id="scenario-count">-</span> scenarios</div>
    <div class="stat"><span class="stat-value" id="outcome-count">-</span> outcomes</div>
    <div class="stat"><span class="stat-value" id="conditional-count">-</span> conditional forecasts</div>
  </div>
  <div class="explorer-container">
    <svg class="connections-svg" id="connections-svg"></svg>
    <div class="explorer" id="explorer">
      <div class="column" id="signals-col">
        <div class="column-header">Signals</div>
        <div class="cards-container" id="signals-container">
          <div class="loading">Loading...</div>
        </div>
      </div>
      <div class="column scenarios-column" id="scenarios-col">
        <div class="column-header">Scenarios (2050)</div>
        <div class="cards-container" id="scenarios-container"></div>
      </div>
      <div class="column" id="questions-col">
        <div class="column-header">Outcomes</div>
        <div class="cards-container" id="questions-container"></div>
      </div>
    </div>
  </div>

  <script>
    // Format helper (2 significant digits)
    const sig2 = v => {
      if (v === 0) return '0';
      const mag = Math.floor(Math.log10(Math.abs(v)));
      const rounded = Math.round(v / Math.pow(10, mag - 1)) * Math.pow(10, mag - 1);
      if (mag >= 2) return rounded.toFixed(0);
      if (mag >= 0) return rounded.toFixed(Math.max(0, 1 - mag));
      return rounded.toPrecision(2);
    };

    // Create formatter from unit metadata
    function createFormatter(unit) {
      if (!unit) return v => `${sig2(v)}`;

      const { type, short_label } = unit;
      switch (type) {
        case 'usd_trillions':
          return v => `$${sig2(v)}T`;
        case 'usd':
          return v => `$${sig2(v)}`;
        case 'population_billions':
          return v => `${sig2(v)}B`;
        case 'percent':
          return v => `${sig2(v)}%`;
        case 'years':
          return v => `${sig2(v)} yrs`;
        case 'rate':
          return v => `${sig2(v)} per 1k`;
        case 'count':
          return v => v >= 1e6 ? `${sig2(v/1e6)}M` : v >= 1e3 ? `${sig2(v/1e3)}K` : `${sig2(v)}`;
        default:
          return v => `${sig2(v)}${short_label || ''}`;
      }
    }

    // Load and transform data from JSON
    async function loadData() {
      const response = await fetch('forecast_tree.json');
      const tree = await response.json();

      const questions = tree.questions.map(q => ({
        id: q.id,
        name: q.display_name || q.text,
        domain: q.domain,
        unit: q.unit,
        format: createFormatter(q.unit),
        expected: q.expected,
        min: q.min,
        max: q.max
      }));

      // Scenarios come pre-sorted by probability and with outcomes pre-joined
      const scenarios = tree.global_scenarios.map(s => ({
        id: s.id,
        name: s.name,
        description: s.description,
        probability: s.probability,
        outcomes: s.outcomes
      }));

      // Signals use view-ready direction (up/down) and magnitude (strong/moderate/weak)
      // Use full text for name - CSS line-clamp handles truncation, expands when highlighted
      const drivers = tree.signals.map(sig => ({
        id: sig.id,
        name: sig.text,
        effects: [{
          scenario: sig.scenario_id,
          direction: sig.direction,
          strength: sig.magnitude
        }]
      }));

      return { questions, scenarios, drivers };
    }

    // Main initialization
    loadData().then(({ questions, scenarios, drivers }) => {
      document.getElementById('signal-count').textContent = drivers.length;
      document.getElementById('scenario-count').textContent = scenarios.length;
      document.getElementById('outcome-count').textContent = questions.length;
      document.getElementById('conditional-count').textContent = drivers.length * scenarios.length;

      // Build questionRanges from pre-computed aggregates on questions
      const questionRanges = {};
      questions.forEach(q => {
        if (q.expected !== undefined) {
          questionRanges[q.id] = {
            min: q.min,
            max: q.max,
            expected: q.expected,
            format: q.format
          };
        }
      });

      const signalsContainer = document.getElementById('signals-container');
      signalsContainer.innerHTML = '';
      drivers.forEach(d => {
        const card = document.createElement('div');
        card.className = 'card signal-card';
        card.dataset.driver = d.id;
        card.dataset.effects = JSON.stringify(d.effects);

        const effectTags = d.effects.map(e => {
          const s = scenarios.find(x => x.id === e.scenario);
          const arrow = e.direction === 'up' ? '↑' : '↓';
          return `<span class="effect-tag ${e.direction} ${e.strength}"><span class="effect-arrow">${arrow}</span>${s?.name || e.scenario}</span>`;
        }).join('');

        card.innerHTML = `<div class="signal-name">${d.name}</div><div class="signal-effects">${effectTags}</div>`;
        signalsContainer.appendChild(card);
      });

      const scenariosContainer = document.getElementById('scenarios-container');
      scenarios.forEach(s => {
        const card = document.createElement('div');
        card.className = 'card scenario-card';
        card.dataset.scenario = s.id;
        card.innerHTML = `
          <div class="scenario-name">${s.name}</div>
          <div class="scenario-prob">${(s.probability * 100).toFixed(1)}%</div>
          <div class="scenario-bar"><div class="scenario-bar-fill" style="width: ${s.probability * 100 * 5}%"></div></div>
          <div class="scenario-desc">${s.description}</div>
        `;
        scenariosContainer.appendChild(card);
      });

      const questionsContainer = document.getElementById('questions-container');
      questions.forEach(q => {
        const card = document.createElement('div');
        card.className = 'card question-card';
        card.dataset.question = q.id;
        card.innerHTML = `
          <div class="question-name">${q.name}</div>
          <div class="question-domain">${q.domain}</div>
          <div class="question-outcome"></div>
          <div class="question-ci"></div>
        `;
        questionsContainer.appendChild(card);
      });

      const svg = document.getElementById('connections-svg');
      let connections = [];
      let selection = { type: null, id: null };

      function rebuildPaths() {
        svg.innerHTML = '';
        connections = [];
        const explorerRect = document.getElementById('explorer').getBoundingClientRect();
        svg.setAttribute('viewBox', `0 0 ${explorerRect.width} ${explorerRect.height}`);

        // Create scenario→outcome paths
        document.querySelectorAll('.scenario-card').forEach(scenarioCard => {
          const scenarioRect = scenarioCard.getBoundingClientRect();
          const scenarioId = scenarioCard.dataset.scenario;
          const scenario = scenarios.find(s => s.id === scenarioId);

          document.querySelectorAll('.question-card').forEach(questionCard => {
            const questionRect = questionCard.getBoundingClientRect();
            const startX = scenarioRect.right - explorerRect.left;
            const startY = scenarioRect.top + scenarioRect.height / 2 - explorerRect.top;
            const endX = questionRect.left - explorerRect.left;
            const endY = questionRect.top + questionRect.height / 2 - explorerRect.top;
            const midX = (startX + endX) / 2;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
            path.setAttribute('class', 'flow-path');
            path.dataset.scenario = scenarioId;
            path.dataset.question = questionCard.dataset.question;
            path.dataset.defaultWidth = 2 + scenario.probability * 60;
            svg.appendChild(path);
            connections.push(path);
          });
        });

        // Create signal→scenario paths
        document.querySelectorAll('.signal-card').forEach(driverCard => {
          const driverRect = driverCard.getBoundingClientRect();
          const effects = JSON.parse(driverCard.dataset.effects);

          effects.forEach(effect => {
            const scenarioCard = document.querySelector(`.scenario-card[data-scenario="${effect.scenario}"]`);
            if (!scenarioCard) return;
            const scenarioRect = scenarioCard.getBoundingClientRect();

            const startX = driverRect.right - explorerRect.left;
            const startY = driverRect.top + driverRect.height / 2 - explorerRect.top;
            const endX = scenarioRect.left - explorerRect.left;
            const endY = scenarioRect.top + scenarioRect.height / 2 - explorerRect.top;
            const midX = (startX + endX) / 2;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
            path.setAttribute('class', 'flow-path');
            path.dataset.driver = driverCard.dataset.driver;
            path.dataset.scenario = effect.scenario;
            path.dataset.direction = effect.direction;
            path.dataset.defaultWidth = effect.strength === 'strong' ? 4 : effect.strength === 'moderate' ? 3 : 2;
            svg.appendChild(path);
            connections.push(path);
          });
        });

        renderSelection();
      }

      function renderSelection() {
        const { type, id } = selection;

        document.querySelectorAll('.card').forEach(c => {
          c.classList.remove('highlighted', 'dimmed', 'show-expanded');
        });
        document.querySelectorAll('.question-outcome').forEach(el => {
          el.textContent = '';
          el.classList.remove('negative', 'positive');
        });
        document.querySelectorAll('.question-ci').forEach(el => el.textContent = '');

        connections.forEach(path => {
          path.classList.remove('highlighted', 'dimmed', 'outcome-up', 'outcome-down', 'up', 'down');
          path.setAttribute('stroke-width', path.dataset.defaultWidth);
        });

        if (!type || !id) return;

        if (type === 'scenario') {
          const scenario = scenarios.find(s => s.id === id);
          if (!scenario) return;

          let maxAbsDev = 0;
          questions.forEach(q => {
            const r = questionRanges[q.id];
            const outcome = scenario.outcomes[q.id];
            if (outcome !== undefined && r) {
              maxAbsDev = Math.max(maxAbsDev, Math.abs(outcome - r.expected));
            }
          });

          document.querySelectorAll('.scenario-card').forEach(c => {
            c.classList.toggle('highlighted', c.dataset.scenario === id);
            c.classList.toggle('dimmed', c.dataset.scenario !== id);
            c.classList.toggle('show-expanded', c.dataset.scenario === id);
          });

          let firstSignal = null;
          document.querySelectorAll('.signal-card').forEach(c => {
            const effects = JSON.parse(c.dataset.effects);
            const effect = effects.find(e => e.scenario === id);
            c.classList.toggle('highlighted', !!effect);
            c.classList.toggle('dimmed', !effect);
            c.classList.toggle('show-expanded', !!effect);
            if (effect && !firstSignal) firstSignal = c;
          });

          if (firstSignal) {
            const col = document.getElementById('signals-col');
            col.scrollTo({ top: firstSignal.offsetTop - col.clientHeight / 3, behavior: 'smooth' });
          }

          document.querySelectorAll('.question-card').forEach(c => {
            c.classList.add('highlighted');
            const qId = c.dataset.question;
            const outcome = scenario.outcomes[qId];
            const r = questionRanges[qId];
            const outcomeEl = c.querySelector('.question-outcome');
            const ciEl = c.querySelector('.question-ci');

            if (outcome !== undefined && r) {
              const pctChange = ((outcome - r.expected) / r.expected) * 100;
              const pctStr = pctChange >= 0 ? `+${sig2(pctChange)}%` : `${sig2(pctChange)}%`;
              const isNegative = pctChange < 0;

              outcomeEl.textContent = `${r.format(outcome)} (${pctStr})`;
              outcomeEl.classList.toggle('negative', isNegative);
              outcomeEl.classList.toggle('positive', !isNegative);
              ciEl.textContent = `vs E[X]: ${r.format(r.expected)}`;
            }
          });

          connections.forEach(path => {
            const isConnected = path.dataset.scenario === id;
            path.classList.toggle('highlighted', isConnected);
            path.classList.toggle('dimmed', !isConnected);

            if (isConnected) {
              if (path.dataset.driver && path.dataset.direction) {
                path.classList.add(path.dataset.direction);
              }
              if (path.dataset.question) {
                const qId = path.dataset.question;
                const r = questionRanges[qId];
                const outcome = scenario.outcomes[qId];
                if (outcome !== undefined && r) {
                  const deviation = outcome - r.expected;
                  path.classList.add(deviation < 0 ? 'outcome-down' : 'outcome-up');
                  const normalizedMag = maxAbsDev > 0 ? Math.abs(deviation) / maxAbsDev : 0;
                  path.setAttribute('stroke-width', 2 + normalizedMag * 10);
                }
              }
            }
          });

        } else if (type === 'signal') {
          const driverCard = document.querySelector(`.signal-card[data-driver="${id}"]`);
          if (!driverCard) return;
          const effects = JSON.parse(driverCard.dataset.effects);
          const scenarioIds = effects.map(e => e.scenario);

          document.querySelectorAll('.scenario-card').forEach(c => {
            c.classList.toggle('highlighted', scenarioIds.includes(c.dataset.scenario));
            c.classList.toggle('dimmed', !scenarioIds.includes(c.dataset.scenario));
          });

          document.querySelectorAll('.signal-card').forEach(c => {
            c.classList.add('dimmed');
          });
          driverCard.classList.remove('dimmed');
          driverCard.classList.add('highlighted', 'show-expanded');

          document.querySelectorAll('.question-card').forEach(c => {
            c.classList.add('dimmed');
          });

          connections.forEach(path => {
            const isConnected = path.dataset.driver === id;
            path.classList.toggle('highlighted', isConnected);
            path.classList.toggle('dimmed', !isConnected && path.dataset.driver !== undefined);
            if (isConnected && path.dataset.direction) {
              path.classList.add(path.dataset.direction);
            }
          });

        } else if (type === 'question') {
          const r = questionRanges[id];
          if (!r) return;

          let maxAbsEffect = 0;
          scenarios.forEach(s => {
            const outcome = s.outcomes[id];
            if (outcome !== undefined) {
              maxAbsEffect = Math.max(maxAbsEffect, Math.abs(outcome - r.expected));
            }
          });

          document.querySelectorAll('.question-card').forEach(c => {
            const isSelected = c.dataset.question === id;
            c.classList.toggle('highlighted', isSelected);
            c.classList.toggle('dimmed', !isSelected);
            if (isSelected) {
              c.querySelector('.question-outcome').textContent = `E[X]: ${r.format(r.expected)}`;
              c.querySelector('.question-ci').textContent = `${r.format(r.min)} – ${r.format(r.max)}`;
            }
          });

          document.querySelectorAll('.scenario-card').forEach(c => {
            c.classList.add('highlighted');
          });

          document.querySelectorAll('.signal-card').forEach(c => {
            c.classList.add('dimmed');
          });

          connections.forEach(path => {
            const isConnected = path.dataset.question === id;
            path.classList.toggle('highlighted', isConnected);
            path.classList.toggle('dimmed', !isConnected && path.dataset.question !== undefined);

            if (isConnected && path.dataset.scenario) {
              const scenario = scenarios.find(s => s.id === path.dataset.scenario);
              const outcome = scenario?.outcomes[id];
              if (outcome !== undefined) {
                const deviation = outcome - r.expected;
                path.classList.add(deviation < 0 ? 'outcome-down' : 'outcome-up');
                const normalizedMag = maxAbsEffect > 0 ? Math.abs(deviation) / maxAbsEffect : 0;
                path.setAttribute('stroke-width', 2 + normalizedMag * 10);
              }
            }
          });
        }
      }

      setTimeout(rebuildPaths, 100);
      window.addEventListener('resize', () => setTimeout(rebuildPaths, 100));

      document.querySelectorAll('.scenario-card').forEach(card => {
        card.addEventListener('click', () => {
          const id = card.dataset.scenario;
          selection = (selection.type === 'scenario' && selection.id === id)
            ? { type: null, id: null }
            : { type: 'scenario', id };
          renderSelection();
        });
      });

      document.querySelectorAll('.signal-card').forEach(card => {
        card.addEventListener('click', () => {
          const id = card.dataset.driver;
          selection = (selection.type === 'signal' && selection.id === id)
            ? { type: null, id: null }
            : { type: 'signal', id };
          renderSelection();
        });
      });

      document.querySelectorAll('.question-card').forEach(card => {
        card.addEventListener('click', () => {
          const id = card.dataset.question;
          selection = (selection.type === 'question' && selection.id === id)
            ? { type: null, id: null }
            : { type: 'question', id };
          renderSelection();
        });
      });

      document.addEventListener('click', e => {
        if (!e.target.closest('.card')) {
          selection = { type: null, id: null };
          renderSelection();
        }
      });

      document.querySelectorAll('.column').forEach(col => {
        col.addEventListener('scroll', () => requestAnimationFrame(rebuildPaths));
      });
    }).catch(err => {
      document.getElementById('signals-container').innerHTML = `<div class="loading">Error loading data: ${err.message}</div>`;
      console.error(err);
    });
  </script>
</body>
</html>
